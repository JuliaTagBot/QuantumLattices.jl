<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Type traits · QuantumLattices.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://quantum-many-body.github.io/QuantumLattices.jl/latest/man/Prerequisites/TypeTraits/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../../index.html"><img class="logo" src="../../../assets/logo.png" alt="QuantumLattices.jl logo"/></a><h1>QuantumLattices.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../../">Home</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../../../tutorial/UnitcellDescription/">Unitcell Description</a></li><li><a class="toctext" href="../../../tutorial/EngineAppInterface/">Engine App Interface</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../Interfaces/">Interfaces</a></li><li><span class="toctext">Prerequisites</span><ul><li><a class="toctext" href="../Introduction/">Introduction</a></li><li class="current"><a class="toctext" href>Type traits</a><ul class="internal"><li><a class="toctext" href="#EfficientOperations-1">EfficientOperations</a></li><li><a class="toctext" href="#MemoryOrder-1">MemoryOrder</a></li><li><a class="toctext" href="#Manual-1">Manual</a></li></ul></li><li><a class="toctext" href="../Factories/">Factories</a></li><li><a class="toctext" href="../CompositeStructures/">Composite structures</a></li><li><a class="toctext" href="../SimpleTrees/">Simple trees</a></li><li><a class="toctext" href="../NamedVectors/">Named vectors</a></li></ul></li><li><span class="toctext">Mathematics</span><ul><li><a class="toctext" href="../../Mathematics/Introduction/">Introduction</a></li><li><a class="toctext" href="../../Mathematics/Combinatorics/">Combinatorics</a></li><li><a class="toctext" href="../../Mathematics/VectorSpaces/">Vector spaces</a></li><li><a class="toctext" href="../../Mathematics/AlgebraOverFields/">Algebra over fields</a></li><li><a class="toctext" href="../../Mathematics/QuantumNumbers/">Quantum numbers</a></li></ul></li><li><span class="toctext">Essentials</span><ul><li><a class="toctext" href="../../Essentials/Introduction/">Introduction</a></li><li><a class="toctext" href="../../Essentials/Spatials/">Spatials</a></li><li><a class="toctext" href="../../Essentials/DegreesOfFreedom/">Degrees of freedom</a></li><li><a class="toctext" href="../../Essentials/Terms/">Terms</a></li><li><a class="toctext" href="../../Essentials/FockPackage/">Fock package</a></li><li><a class="toctext" href="../../Essentials/SpinPackage/">Spin package</a></li><li><a class="toctext" href="../../Essentials/Extensions/">Extensions</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li>Prerequisites</li><li><a href>Type traits</a></li></ul><a class="edit-page" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/master/docs/src/man/Prerequisites/TypeTraits.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Type traits</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Type-traits-1" href="#Type-traits-1">Type traits</a></h1><p>This module defines generic type traits that are useful to the package.</p><p>Julia does not support multi-inheritance, which is sometimes not convenient. A way around this is to use traits, i.e. by utilizing the dispatch on certain (singleton) types known as traits to simulate multi-inheritance. Although this method cannot aviod small repetitive codes, it suits methods well that are complicated and lengthy.</p><h2><a class="nav-anchor" id="EfficientOperations-1" href="#EfficientOperations-1">EfficientOperations</a></h2><p><code>EfficientOperations</code> defines efficient operations such as <code>==/isequal</code>, <code>&lt;/isless</code>, <code>isapprox</code>, <code>replace</code>, etc, that ensure type stability.</p><p>Type stability is the key of Julia to improve the code efficiency. However, it cannot be ensured in some unexpected cases, especially where an iterator is involved. For example, the following codes appears type unstable:</p><pre><code class="language-julia">function Base.:(==)(o1::AbstractType,o2::AbstractType)
    n1,n2=o1|&gt;typeof|&gt;fieldcount,o2|&gt;typeof|&gt;fieldcount
    n1==n2 ? all(getfield(o1,i)==getfield(o2,i) for i=1:n1) : false
end</code></pre><p>Methods like above are common when we design abstract types, but they are not type stable. To get rid of it, the generated function trick can be used:</p><pre><code class="language-julia">@generated function Base.:(==)(o1::AbstractType,o2::AbstractType)
    n1,n2=o1|&gt;typeof|&gt;fieldcount,o2|&gt;typeof|&gt;fieldcount
    if n1==n2
        expr=:(getfield(o1,1)==getfield(o2,1))
        for i=2:fcount
            expr=Expr(:&amp;&amp;,expr,:(getfield(o1,$i)==getfield(o2,$i)))
        end
        return expr
    else
        return :(false)
    end
end</code></pre><p>Then type stability can be ensured. We use this trick to implement the methods such as <code>==/isequal</code>, <code>&lt;/isless</code>, <code>isapprox</code>, <code>replace</code>, etc, with the trait <code>efficientoperations::EfficientOperations</code>. Other types can resort to these methods by passing <a href="#QuantumLattices.Prerequisites.TypeTraits.efficientoperations"><code>efficientoperations</code></a> as the first argument.</p><h2><a class="nav-anchor" id="MemoryOrder-1" href="#MemoryOrder-1">MemoryOrder</a></h2><p><code>MemoryOrder</code> provides the convertions, <a href="#QuantumLattices.Prerequisites.TypeTraits.subtoind-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},Tuple{Vararg{Int64,N}},FOrder}} where N"><code>subtoind</code></a> and <a href="#QuantumLattices.Prerequisites.TypeTraits.indtosub-Tuple{Tuple,Int64,QuantumLattices.Prerequisites.TypeTraits.FOrder}"><code>indtosub</code></a>, between a Cartesian index represented by a tuple and a linear index represented by an integer. C/C++ order or Fortran order can be specified, though the constant instances <a href="#QuantumLattices.Prerequisites.TypeTraits.corder"><code>corder</code></a> or <a href="#QuantumLattices.Prerequisites.TypeTraits.forder"><code>forder</code></a> of singleton types <code>COrder</code> and <code>FOrder</code>, which are both subtypes of the abstract type <code>MemoryOrder</code>.</p><h2><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumLattices.Prerequisites.TypeTraits.corder" href="#QuantumLattices.Prerequisites.TypeTraits.corder"><code>QuantumLattices.Prerequisites.TypeTraits.corder</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">corder</code></pre><p>Indicate that the convertion between Cartesian index and linear index is using the C/C++ order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/58622ae795a8e9d1f340383090a3afe59302031f/src/Prerequisites/TypeTraits.jl#L126-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumLattices.Prerequisites.TypeTraits.efficientoperations" href="#QuantumLattices.Prerequisites.TypeTraits.efficientoperations"><code>QuantumLattices.Prerequisites.TypeTraits.efficientoperations</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">efficientoperations</code></pre><p>Indicate that the efficient operations, i.e. &quot;==&quot;/&quot;isequal&quot;, &quot;&lt;&quot;/&quot;isless&quot; or &quot;replace&quot;, will be used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/58622ae795a8e9d1f340383090a3afe59302031f/src/Prerequisites/TypeTraits.jl#L10-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumLattices.Prerequisites.TypeTraits.forder" href="#QuantumLattices.Prerequisites.TypeTraits.forder"><code>QuantumLattices.Prerequisites.TypeTraits.forder</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">forder</code></pre><p>Indicate that the convertion between Cartesian index and linear index is using the Fortran order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/58622ae795a8e9d1f340383090a3afe59302031f/src/Prerequisites/TypeTraits.jl#L120-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumLattices.Prerequisites.TypeTraits.indtosub-Tuple{Tuple,Int64,QuantumLattices.Prerequisites.TypeTraits.FOrder}" href="#QuantumLattices.Prerequisites.TypeTraits.indtosub-Tuple{Tuple,Int64,QuantumLattices.Prerequisites.TypeTraits.FOrder}"><code>QuantumLattices.Prerequisites.TypeTraits.indtosub</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">indtosub(dims::Tuple,ind::Int,order::FOrder) -&gt; Tuple
indtosub(dims::Tuple,ind::Int,order::COrder) -&gt; Tuple</code></pre><p>Convert an linear index to Cartesian index. Fortran-order or C-order can be assigned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/58622ae795a8e9d1f340383090a3afe59302031f/src/Prerequisites/TypeTraits.jl#L136-L141">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumLattices.Prerequisites.TypeTraits.subtoind-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},Tuple{Vararg{Int64,N}},FOrder}} where N" href="#QuantumLattices.Prerequisites.TypeTraits.subtoind-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},Tuple{Vararg{Int64,N}},FOrder}} where N"><code>QuantumLattices.Prerequisites.TypeTraits.subtoind</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">subtoind(dims::NTuple{N,Int},inds::NTuple{N,Int},order::FOrder) where N -&gt; Int
subtoind(dims::NTuple{N,Int},inds::NTuple{N,Int},order::COrder) where N -&gt; Int</code></pre><p>Convert an Cartesian index to linear index. Fortran-order or C-order can be assigned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/58622ae795a8e9d1f340383090a3afe59302031f/src/Prerequisites/TypeTraits.jl#L151-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&lt;-Tuple{QuantumLattices.Prerequisites.TypeTraits.EfficientOperations,Any,Any}" href="#Base.:&lt;-Tuple{QuantumLattices.Prerequisites.TypeTraits.EfficientOperations,Any,Any}"><code>Base.:&lt;</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">&lt;(::EfficientOperations,o1,o2) -&gt; Bool
isless(::EfficientOperations,o1,o2) -&gt; Bool</code></pre><p>Compare two objects and judge whether the first is less than the second.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/58622ae795a8e9d1f340383090a3afe59302031f/src/Prerequisites/TypeTraits.jl#L56-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Tuple{QuantumLattices.Prerequisites.TypeTraits.EfficientOperations,Any,Any}" href="#Base.:==-Tuple{QuantumLattices.Prerequisites.TypeTraits.EfficientOperations,Any,Any}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">==(::EfficientOperations,o1,o2) -&gt; Bool
isequal(::EfficientOperations,o1,o2) -&gt; Bool</code></pre><p>Compare two objects and judge whether they are eqaul to each other.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/58622ae795a8e9d1f340383090a3afe59302031f/src/Prerequisites/TypeTraits.jl#L17-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isapprox-Union{Tuple{Names}, Tuple{EfficientOperations,Val{Names},Any,Any}} where Names" href="#Base.isapprox-Union{Tuple{Names}, Tuple{EfficientOperations,Val{Names},Any,Any}} where Names"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isapprox(::EfficientOperations,::Val{Names},o1,o2;atol::Real=atol,rtol::Real=rtol) where Names -&gt; Bool</code></pre><p>Compare two objects and judge whether they are inexactly equivalent to each other.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/58622ae795a8e9d1f340383090a3afe59302031f/src/Prerequisites/TypeTraits.jl#L85-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.replace-Tuple{QuantumLattices.Prerequisites.TypeTraits.EfficientOperations,Any}" href="#Base.replace-Tuple{QuantumLattices.Prerequisites.TypeTraits.EfficientOperations,Any}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">replace(::EfficientOperations,o;kwargs...) -&gt; typeof(o)</code></pre><p>Return a copy of the input object with some of the field values replaced by the keyword arguments.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/58622ae795a8e9d1f340383090a3afe59302031f/src/Prerequisites/TypeTraits.jl#L107-L111">source</a></section><footer><hr/><a class="previous" href="../Introduction/"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../Factories/"><span class="direction">Next</span><span class="title">Factories</span></a></footer></article></body></html>
