<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Unitcell Description · QuantumLattices.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://quantum-many-body.github.io/QuantumLattices.jl/latest/tutorials/UnitcellDescription/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="QuantumLattices.jl logo"/></a><h1>QuantumLattices.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li class="current"><a class="toctext" href>Unitcell Description</a><ul class="internal"><li><a class="toctext" href="#Spatial-info-of-a-unitcell-1">Spatial info of a unitcell</a></li><li><a class="toctext" href="#Internal-degrees-of-freedom-1">Internal degrees of freedom</a></li><li><a class="toctext" href="#Couplings-among-different-degrees-of-freedom-1">Couplings among different degrees of freedom</a></li></ul></li><li><a class="toctext" href="../EngineAppInterface/">Engine App Interface</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/Interfaces/">Interfaces</a></li><li><span class="toctext">Prerequisites</span><ul><li><a class="toctext" href="../../man/Prerequisites/Introduction/">Introduction</a></li><li><a class="toctext" href="../../man/Prerequisites/TypeTraits/">Type traits</a></li><li><a class="toctext" href="../../man/Prerequisites/Factories/">Factories</a></li><li><a class="toctext" href="../../man/Prerequisites/CompositeStructures/">Composite structures</a></li><li><a class="toctext" href="../../man/Prerequisites/SimpleTrees/">Simple trees</a></li><li><a class="toctext" href="../../man/Prerequisites/NamedVectors/">Named vectors</a></li></ul></li><li><span class="toctext">Mathematics</span><ul><li><a class="toctext" href="../../man/Mathematics/Introduction/">Introduction</a></li><li><a class="toctext" href="../../man/Mathematics/Combinatorics/">Combinatorics</a></li><li><a class="toctext" href="../../man/Mathematics/VectorSpaces/">Vector spaces</a></li><li><a class="toctext" href="../../man/Mathematics/AlgebraOverFields/">Algebra over fields</a></li><li><a class="toctext" href="../../man/Mathematics/QuantumNumbers/">Quantum numbers</a></li></ul></li><li><span class="toctext">Essentials</span><ul><li><a class="toctext" href="../../man/Essentials/Introduction/">Introduction</a></li><li><a class="toctext" href="../../man/Essentials/Spatials/">Spatials</a></li><li><a class="toctext" href="../../man/Essentials/DegreesOfFreedom/">Degrees of freedom</a></li><li><a class="toctext" href="../../man/Essentials/Terms/">Terms</a></li><li><a class="toctext" href="../../man/Essentials/FockPackage/">Fock package</a></li><li><a class="toctext" href="../../man/Essentials/SpinPackage/">Spin package</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Unitcell Description</a></li></ul><a class="edit-page" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/master/docs/src/tutorials/UnitcellDescription.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Unitcell Description</span><a class="fa fa-bars" href="#"></a></div></header><div></div><h1><a class="nav-anchor" id="Unitcell-Description-1" href="#Unitcell-Description-1">Unitcell Description</a></h1><p>A quantum lattice system can be completely described within its unitcell. Bascially, this description should contain three types of information:</p><ol><li>the spatial information, such as the the coordinates of the points contained in the unitcell;</li><li>the internal degrees of freedom, such as the local Hilbert space on each point;</li><li>the couplings among different degrees of freedom, such as the interaction terms in the Hamiltonian.</li></ol><p>In theory, as long as the above information is told, one could easily write down the operator representation of the Hamiltonian of the system. For example, in the phrase <em>&quot;the single orbital electronic Hubbard model with only nearest neighbor hopping on a one dimensional lattice with only two sites&quot;</em>, <em>&quot;one dimensional lattice with only two sites&quot;</em> is the spatial information, <em>&quot;single orbital electronic&quot;</em> defines the local Hilbert spaces, and <em>&quot;Hubbard model with only nearest neighbor hopping&quot;</em> describes the terms present in the Hamiltonian. From this phrase, we also know that the Hamiltonian of the system is</p><div>\[H=tc^†_{1↑}c_{2↑}+tc^†_{2↑}c_{1↑}+tc^†_{1↓}c_{2↓}+tc^†_{2↓}c_{1↓}+Uc^†_{1↑}c_{1↑}c^†_{1↓}c_{1↓}+Uc^†_{2↑}c_{2↑}c^†_{2↓}c_{2↓}\]</div><p>where <span>$t$</span> is the hopping amplitude and <span>$U$</span> is the Hubbard interaction strength. Actually, the <strong>unitcell description framework</strong> follows exactly after the above train of thought. For example, the forementioned system can be constructed by the following codes</p><pre><code class="language-julia">using QuantumLattices
using SymPy: symbols

# define the unitcell
lattice=Lattice(&quot;L2P&quot;,[Point(PID(1),(0.0,)),Point(PID(2),(1.0,))])

# define the internal degrees of freedom
config=IDFConfig{Fock}(pid-&gt;Fock(norbital=1,nspin=2,nnambu=2),lattice.pids)

# define the terms
t=Hopping{&#39;F&#39;}(:t,symbols(&quot;t&quot;,real=true),1)
U=Hubbard{&#39;F&#39;}(:U,symbols(&quot;U&quot;,real=true))

# get the Hamiltonian
operators=expand(Generator((t,U),Bonds(lattice),config,nothing,false))</code></pre><div>\[tc^{\dagger}_{1,1,↑}c^{}_{2,1,↑}+tc^{\dagger}_{1,1,↓}c^{}_{2,1,↓}+tc^{\dagger}_{2,1,↑}c^{}_{1,1,↑}+tc^{\dagger}_{2,1,↓}c^{}_{1,1,↓}+Uc^{\dagger}_{1,1,↑}c^{}_{1,1,↑}c^{\dagger}_{1,1,↓}c^{}_{1,1,↓}+Uc^{\dagger}_{2,1,↑}c^{}_{2,1,↑}c^{\dagger}_{2,1,↓}c^{}_{2,1,↓}\]</div><p>The last line displays all the generated operators in the Hamiltonian in the latex form. In the following sections, we will explain in brief how these codes work. For detailed explanations, please refer to the manual of <a href="../../man/Essentials/Introduction/#essentails-1"><code>Essentials</code></a>.</p><h2><a class="nav-anchor" id="Spatial-info-of-a-unitcell-1" href="#Spatial-info-of-a-unitcell-1">Spatial info of a unitcell</a></h2><h3><a class="nav-anchor" id="Point-1" href="#Point-1">Point</a></h3><p>The basic data structure encoding the spatial info of a unitcell is <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Point"><code>Point</code></a>.</p><p>Theoretically, the only information that is needed to determine a point in a lattice is its coordinates in the real space. Now that coordinates sometimes are complicated real numbers and are not convenient for lookup, it is desirable to attach to each point with a sensible id. Then you may agree that the most appropriate data structure representing a point should contain two parts, the id part and the coordinate part. But the story does not end up here. This is because we want to compress the whole spatial info of a lattice into its unitcells. For each lattice, there exists a freedom to choose its unitcells. Sometimes we even need enlarged unitcells. Therefore, something must be adopted to keep the info of which unitcell a point belongs to in the lattice. This information is useful even when we only keep the data of points within a single unitcell because at this time we usually have to obtain those bonds across the unitcell boundaries that must contain a point in other unitcells. Now we arrive at the final structure, just as the <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Point"><code>Point</code></a> defined in this package, which has three attributes:</p><ul><li><code>pid::</code><a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.PID"><code>PID</code></a>: the id of a point</li><li><code>rcoord::</code><a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>StaticArrays.SVector</code></a>: the coordinates of the point in the real space</li><li><code>icoord::</code><a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>StaticArrays.SVector</code></a>: the coordinates of the unitcell the point belongs to in the real space</li></ul><p>Here <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.PID"><code>PID</code></a> constains two attributes:</p><ul><li><code>scope::Any</code>: the scope of a point</li><li><code>site::Int</code>: the site index of a point</li></ul><p>The <code>:site</code> attribute is necessary and easy to understand for a point id. Yet sometimes it is more convenient if we can assign extra informations to a point id, e.g., a prioi knowledge of the groupings of lattice points. Therefore, we provide another attribute, <code>:scope</code>, to act as the supplement to the <code>:site</code> attribute, which can be anything you want.</p><p>Let&#39;s see some examples.</p><p>You can specify both the <code>:scope</code> attribute and the <code>:site</code> attribute during the initialization of a <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.PID"><code>PID</code></a>:</p><pre><code class="language-julia">PID(&quot;WhateverYouWant&quot;,1)</code></pre><pre><code class="language-none">PID(&quot;WhateverYouWant&quot;,1)</code></pre><p>Or, you can omit the <code>:scope</code> attribute:</p><pre><code class="language-julia">PID(1)</code></pre><pre><code class="language-none">PID(&#39;T&#39;,1)</code></pre><p>Then the <code>:scope</code> attribute get a default value <code>&#39;T&#39;</code>, which is short for the nick name of my girl friend.</p><p>At the construction of a <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Point"><code>Point</code></a>, <code>:rcoord</code> and <code>:icoord</code> can accept tuples as inputs, such as</p><pre><code class="language-julia">Point(PID(1),(0.0,),(0.0,))</code></pre><pre><code class="language-none">Point(PID(&#39;T&#39;,1),[0.0],[0.0])</code></pre><p>If the <code>:icoord</code> is omitted, it will be initialized by a zero <a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>StaticArrays.SVector</code></a>:</p><pre><code class="language-julia">Point(PID(1),(0.0,))</code></pre><pre><code class="language-none">Point(PID(&#39;T&#39;,1),[0.0],[0.0])</code></pre><h3><a class="nav-anchor" id="Lattice-1" href="#Lattice-1">Lattice</a></h3><p><a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Lattice"><code>Lattice</code></a> is the simplest structure to encode all the spatial info within a unitcell. Apparently, it must contain all the points of a unitcell. Besides, a unitcell can assume either open or periodic boundary for every spatial dimension, thus a <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Lattice"><code>Lattice</code></a> should also contain the translation vectors. Other stuff also appears to be useful, such as the name, the reciprocals dual to the translation vectors, and the bond length of each order of nearest neighbors. Therefore, in this package, <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Lattice"><code>Lattice</code></a> gets seven attributes:</p><ul><li><code>name::String</code>: the name of the lattice</li><li><code>pids::Vector{&lt;:PID}</code>: the pids of the lattice</li><li><code>rcoords::Matrix{Float64}</code>: the rcoords of the lattice</li><li><code>icoords::Matrix{Float64}</code>: the icoords of the lattice</li><li><code>vectors::Vector{&lt;:StaticArrays.SVector}</code>: the translation vectors of the lattice</li><li><code>reciprocals::Vector{&lt;:StaticArrays.SVector}</code>: the reciprocals of the lattice</li><li><code>neighbors::Dict{Int,Float64}</code>: the order-distance map of the nearest neighbors of the lattice</li></ul><p>Here, the <code>:pids</code>, <code>:rcoords</code> and <code>:icoords</code> attributes decompose the points in a lattice, which makes it convenient for global operations on the lattice.</p><p>Points can be used directly to constuct a lattice, whereas <code>:vectors</code> and <code>neighbors</code> can be assigned by keyword arguments:</p><pre><code class="language-julia">Lattice(&quot;L2P&quot;,[Point(PID(1),(0.0,)),Point(PID(2),(1.0,))],
        vectors=[[2.0]],
        neighbors=Dict(1=&gt;1.0,2=&gt;2.0)
        )</code></pre><pre><code class="language-none">Lattice(L2P)
  with 2 points:
    Point(PID(&#39;T&#39;,1),[0.0],[0.0])
    Point(PID(&#39;T&#39;,2),[1.0],[0.0])
  with 1 translation vector:
    [2.0]
  with 2 orders of nearest neighbors:
    2=&gt;2.0
    1=&gt;1.0
</code></pre><p>The <code>:neighbors</code> keyword argument can also be a natural number, which sets the highest order of nearest neighbors, and the order-distance map of nearest neighbors can be computed automatically by the construction function:</p><pre><code class="language-julia">Lattice(&quot;L2P&quot;,[Point(PID(1),(0.0,)),Point(PID(2),(1.0,))],vectors=[[2.0]],neighbors=2)</code></pre><pre><code class="language-none">Lattice(L2P)
  with 2 points:
    Point(PID(&#39;T&#39;,1),[0.0],[0.0])
    Point(PID(&#39;T&#39;,2),[1.0],[0.0])
  with 1 translation vector:
    [2.0]
  with 2 orders of nearest neighbors:
    2=&gt;2.0
    1=&gt;1.0
</code></pre><p>It is noted that the <code>:vectors</code> and <code>:neighbors</code> attributes can also be omitted at the initialization, then <code>:vectors</code> will be set to be empty and <code>:neighbors</code> to be 1 upon the call of the construction function:</p><pre><code class="language-julia">Lattice(&quot;L2P&quot;,[Point(PID(1),(0.0,)),Point(PID(2),(1.0,))])</code></pre><pre><code class="language-none">Lattice(L2P)
  with 2 points:
    Point(PID(&#39;T&#39;,1),[0.0],[0.0])
    Point(PID(&#39;T&#39;,2),[1.0],[0.0])
  with 1 order of nearest neighbors:
    1=&gt;1.0
</code></pre><p>In all cases, the <code>:reciprocals</code> attributes need not be assigned because it can be deduced from the input <code>:vectors</code>.</p><h3><a class="nav-anchor" id="Bonds-1" href="#Bonds-1">Bonds</a></h3><p>One of the most important functions of a lattice is to inquiry the bonds it contains.</p><p>A usaual bond contians two points, the start point and the end point. This structure is implemented as <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Bond"><code>Bond</code></a>, which has three attributes:</p><ul><li><code>neighbor::Int</code>: the nearest neighbor order of the bond</li><li><code>spoint::Point</code>: the start point of the bond</li><li><code>epoint::Point</code>: the end point of the bond</li></ul><p>The <code>:neighbor</code> provides the a prioi info of the nearest neighbor order of a bond, which proves to be quite advantageous in future uses.</p><p>There are other types of generalized bonds. In fact, a single point can also be viewed as a kind of bond, namely, the zeroth order nearest neighbor bond. We can also have more complex generalized bonds, such as a plaquette (the minimum four-site square) in the square lattice. All these generalized bonds gather under the abstract type, <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.AbstractBond"><code>AbstractBond</code></a>, and the generation from a lattice of such generalized bonds can be managed by the type <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Bonds"><code>Bonds</code></a>. In this package, we only implemente two types of concrete generalized bonds, i.e. <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Point"><code>Point</code></a> and <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Bond"><code>Bond</code></a>. Users interested in other types can define them themselves by extending our protocols. In this way, the management of the generation of these user extended bonds can be utilized by <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Bonds"><code>Bonds</code></a> without extra modifications. See <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Bonds"><code>Bonds</code></a> for more details.</p><p>Now let&#39;s see a simple example:</p><pre><code class="language-julia">lattice=Lattice(&quot;L2P&quot;,[Point(PID(1),(0.0,)),Point(PID(2),(1.0,))],
                vectors=[[2.0]],
                neighbors=2
                )
Bonds(lattice)</code></pre><pre><code class="language-none">6-element Bonds:
 Point(PID(&#39;T&#39;,1),[0.0],[0.0])                                        
 Point(PID(&#39;T&#39;,2),[1.0],[0.0])                                        
 Bond(1,Point(PID(&#39;T&#39;,1),[0.0],[0.0]),Point(PID(&#39;T&#39;,2),[1.0],[0.0]))  
 Bond(2,Point(PID(&#39;T&#39;,1),[0.0],[0.0]),Point(PID(&#39;T&#39;,1),[-2.0],[-2.0]))
 Bond(1,Point(PID(&#39;T&#39;,1),[0.0],[0.0]),Point(PID(&#39;T&#39;,2),[-1.0],[-2.0]))
 Bond(2,Point(PID(&#39;T&#39;,2),[1.0],[0.0]),Point(PID(&#39;T&#39;,2),[-1.0],[-2.0]))</code></pre><p>By default, <code>Bonds(lattice::Lattice)</code> generates all the generalized bonds with orders of nearest neighbors specified by the attribute <code>:neighbors</code> of the input lattice, including the individual points and the bonds across the periodic boundaries. Note that the bonds whose lengths are not present in the <code>:neighbors</code> attribute of the input lattice won&#39;t be included in the result, even when their lengths are shorter:</p><pre><code class="language-julia">lattice=Lattice(&quot;L2P&quot;,[Point(PID(1),(0.0,)),Point(PID(2),(1.0,))],
                vectors=[[2.0]],
                neighbors=Dict(2=&gt;2.0)
                )
Bonds(lattice)</code></pre><pre><code class="language-none">4-element Bonds:
 Point(PID(&#39;T&#39;,1),[0.0],[0.0])                                        
 Point(PID(&#39;T&#39;,2),[1.0],[0.0])                                        
 Bond(2,Point(PID(&#39;T&#39;,1),[0.0],[0.0]),Point(PID(&#39;T&#39;,1),[-2.0],[-2.0]))
 Bond(2,Point(PID(&#39;T&#39;,2),[1.0],[0.0]),Point(PID(&#39;T&#39;,2),[-1.0],[-2.0]))</code></pre><p>In other words, the <code>:neighbors</code> attribute can be viewed as a filter of the generated bonds (but this filter only affects the <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Bond"><code>Bond</code></a> typed but not the <a href="../../man/Essentials/Spatials/#QuantumLattices.Essentials.Spatials.Point"><code>Point</code></a> typed generalized bonds). When the input lattice has no translation vectors, the generated bonds will only contain the individual points and the intra-unitcell bonds, just as expected:</p><pre><code class="language-julia">lattice=Lattice(&quot;L2P&quot;,[Point(PID(1),(0.0,)),Point(PID(2),(1.0,))])
Bonds(lattice)</code></pre><pre><code class="language-none">3-element Bonds:
 Point(PID(&#39;T&#39;,1),[0.0],[0.0])                                      
 Point(PID(&#39;T&#39;,2),[1.0],[0.0])                                      
 Bond(1,Point(PID(&#39;T&#39;,1),[0.0],[0.0]),Point(PID(&#39;T&#39;,2),[1.0],[0.0]))</code></pre><h2><a class="nav-anchor" id="Internal-degrees-of-freedom-1" href="#Internal-degrees-of-freedom-1">Internal degrees of freedom</a></h2><h2><a class="nav-anchor" id="Couplings-among-different-degrees-of-freedom-1" href="#Couplings-among-different-degrees-of-freedom-1">Couplings among different degrees of freedom</a></h2><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../EngineAppInterface/"><span class="direction">Next</span><span class="title">Engine App Interface</span></a></footer></article></body></html>
