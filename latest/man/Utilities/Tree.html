<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tree · Hamiltonian.jl</title><link rel="canonical" href="https://quantum-many-body.github.io/Hamiltonian.jl/latest/man/Utilities/Tree.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Hamiltonian.jl logo"/></a><h1>Hamiltonian.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">Home</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../../tutorial/UnitcellDescription.html">Unitcell Description</a></li><li><a class="toctext" href="../../tutorial/EngineAppInterface.html">Engine App Interface</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><span class="toctext">Utilities</span><ul><li><a class="toctext" href="Introduction.html">Introduction</a></li><li><a class="toctext" href="Factory.html">Factory</a></li><li><a class="toctext" href="CompositeStructure.html">Composite structure</a></li><li class="current"><a class="toctext" href="Tree.html">Tree</a><ul class="internal"><li><a class="toctext" href="#AbstractTree-1">AbstractTree</a></li><li><a class="toctext" href="#TreeCore-and-SimpleTree-1">TreeCore and SimpleTree</a></li><li><a class="toctext" href="#Manual-1">Manual</a></li></ul></li><li><a class="toctext" href="NamedVector.html">Named vector</a></li><li><a class="toctext" href="AlgebraOverField.html">Algebra over fields</a></li><li><a class="toctext" href="QuantumNumber.html">Quantum numbers</a></li></ul></li><li><span class="toctext">Essentials</span><ul><li><a class="toctext" href="../Essentials/Introduction.html">Introduction</a></li><li><a class="toctext" href="../Essentials/Spatial.html">Spatial</a></li><li><a class="toctext" href="../Essentials/DegreeOfFreedom.html">DegreeOfFreedom</a></li><li><a class="toctext" href="../Essentials/FockPackage.html">Fock Package</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li>Utilities</li><li><a href="Tree.html">Tree</a></li></ul><a class="edit-page" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/master/docs/src/man/Utilities/Tree.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tree</span><a class="fa fa-bars" href="#"></a></div></header><div></div><h1><a class="nav-anchor" id="Tree-1" href="#Tree-1">Tree</a></h1><p>The aim of the tree in this module is to represent the standard tree structure in efficiency-non-sensitive cases. Please note that the default implementation of tree methods are far from optimal in efficiency. Therefore, please <strong>DO NOT</strong> use it if you need an efficient tree for addition, deletion, sort and inquiry. This module of codes apply only when the structure of tree matters but not the efficiency.</p><h2><a class="nav-anchor" id="AbstractTree-1" href="#AbstractTree-1">AbstractTree</a></h2><p><a href="Tree.html#Hamiltonian.Utilities.Tree.AbstractTree"><code>AbstractTree{N,D}</code></a> is the abstract type for all concrete trees. By design, it has two type parameters:</p><ul><li><code>N</code>: the type of the tree&#39;s node</li><li><code>D</code>: the type of the tree&#39;s data</li></ul><p>To fully utilize the methods designed for a tree structure, in our protocol, a concrete subtype must implement the following methods:</p><ul><li>inquiry related methods<pre><code class="language-julia">root(tree::AbstractTree{N,D}) where {N,D} -&gt; Union{N,Nothing}
haskey(tree::AbstractTree{N,D},node::N) where {N,D} -&gt; Bool
length(tree::AbstractTree) -&gt; Int
parent(tree::AbstractTree{N,D},node::N,superparent::Union{N,Nothing}=nothing) where {N,D} -&gt; Union{N,Nothing}
children(tree::AbstractTree{N,D},node::N) where {N,D} -&gt; Vector{N}</code></pre><ul><li>Get a tree&#39;s root node (<code>nothing</code> for empty trees)</li><li>Get the number of a tree&#39;s nodes.</li><li>Check whether a node is in a tree.</li><li>Get the parent of a tree&#39;s node or return superparent when the input node is the tree&#39;s root.</li><li>Get the children of a tree&#39;s node.</li></ul></li><li>structure modification related methods<pre><code class="language-julia">addnode!(tree::AbstractTree{N,D},parent::Union{N,Nothing},node::N) where {N,D}
deletenode!(tree::AbstractTree{N,D},node::N) where {N,D}</code></pre><ul><li>Update the structure of a tree by adding a node. When the parent is <code>nothing</code>, the input tree must be empty and the input node becomes the tree&#39;s root.</li><li>Update the structure of a tree by deleting a node.</li></ul></li><li>index related methods<pre><code class="language-julia">getindex(tree::AbstractTree{N,D},node::N) where {N,D} -&gt; D
setindex!(tree::AbstractTree{N,D},node::N,data::D) where {N,D}</code></pre><ul><li>Get the data of a tree&#39;s node</li><li>Set the data of a tree&#39;s node.</li></ul></li></ul><p>Based on these methods, we implement several generic functions for inquiries and manipulations</p><ul><li>inquiry for type parameters: <a href="Tree.html#Base.keytype-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}"><code>keytype</code></a>, <a href="Tree.html#Base.valtype-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}"><code>valtype</code></a>, <code>eltype</code></li><li>expansion over nodes/data-records: <code>keys</code>, <code>values</code>, <code>pairs</code></li><li>inquiry for info of nodes: <a href="Tree.html#Hamiltonian.Utilities.Tree.isleaf-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N"><code>isleaf</code></a>, <a href="Tree.html#Hamiltonian.Utilities.Tree.level-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N"><code>level</code></a></li><li>inquiry for nodes: <a href="Tree.html#Hamiltonian.Utilities.Tree.ancestor-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}, Tuple{AbstractTree{N,D},N,Int64}} where D where N"><code>ancestor</code></a>, <a href="Tree.html#Hamiltonian.Utilities.Tree.descendants-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}, Tuple{AbstractTree{N,D},N,Int64}} where D where N"><code>descendants</code></a>, <a href="Tree.html#Hamiltonian.Utilities.Tree.siblings-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N"><code>siblings</code></a>, <a href="Tree.html#Hamiltonian.Utilities.Tree.leaves-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}"><code>leaves</code></a></li><li>modification: <a href="Tree.html#Base.push!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N,D}} where D where N"><code>push!</code></a>, <a href="Tree.html#Base.append!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},AbstractTree{N,D}}} where D where N"><code>append!</code></a>, <a href="Tree.html#Base.delete!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N"><code>delete!</code></a>, <a href="Tree.html#Base.empty!-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}"><code>empty!</code></a></li></ul><p>And optionally, when a subtype implement the following method,</p><pre><code class="language-julia">empty(tree::AbstractTree) -&gt; typeof(tree)</code></pre><p>which constructs an empty tree of the same type with the input one, two more more methods are supported:</p><ul><li><a href="Tree.html#Hamiltonian.Utilities.Tree.subtree-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N"><code>subtree</code></a>: Get a subtree starting from a node.</li><li><a href="Tree.html#Hamiltonian.Utilities.Tree.move!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N,N}} where D where N"><code>move!</code></a>: Move a subtree to a new position.</li></ul><h2><a class="nav-anchor" id="TreeCore-and-SimpleTree-1" href="#TreeCore-and-SimpleTree-1">TreeCore and SimpleTree</a></h2><p>To implement all the prerequisites listed above costs a bit efforts. We provide two lazy ways to get over this:</p><ol><li>Inheritance <code>AbstractTree</code> with <code>TREECORE::TreeCore</code> as the <strong>last</strong> attribute</li><li>Inclusion an attribute which is an instance of <a href="Tree.html#Hamiltonian.Utilities.Tree.SimpleTree"><code>SimpleTree</code></a></li></ol><h3><a class="nav-anchor" id="TreeCore-1" href="#TreeCore-1">TreeCore</a></h3><p><a href="Tree.html#Hamiltonian.Utilities.Tree.TreeCore"><code>TreeCore{N,D}</code></a>, as the literal meaning indicates, is the core of a tree. It encapsulates all the data structures needed by the default implementation, which constains <strong>4</strong> attributes:</p><ul><li><code>root::N</code>: the tree&#39;s root node</li><li><code>contents::Dict{N,D}</code>: the tree&#39;s (node,data) pairs</li><li><code>parent::Dict{N,N}</code>: records of the parent of each of the tree&#39;s nodes</li><li><code>children::Dict{N,Vector{N}}</code>: records of the children of each of the tree&#39;s nodes</li></ul><p>As above, the first lazy way is to include this struct with the special name <code>:TREECORE</code> in your concrete subtype as the <strong>last</strong> attribute. This process can be even lazier, in that we provide a macro <a href="Tree.html#Hamiltonian.Utilities.Tree.@tree"><code>@tree</code></a> to decorate your &quot;raw&quot; struct automatically, e.g.</p><pre><code class="language-julia-repl">julia&gt; @tree struct SimpleSubTree end

julia&gt; @tree struct SubTreeWithTreeParameters end {N&lt;:AbstractString,D&lt;:Number}

julia&gt; @tree struct SubTreeWithCertainTreeParameters end {&lt;:String,&lt;:Int}

julia&gt; @tree struct SubTreeWithFields info::Vector{Int} end {N&lt;:AbstractString,D&lt;:Number}

julia&gt; @tree struct SubTreeWithParametricFields{T} info::Vector{T} end {N&lt;:AbstractString,D&lt;:Number}

julia&gt; @tree struct SubTreeWithOverlappedParametricFields{N} info::Vector{N} end {N&lt;:AbstractString,D&lt;:Number}</code></pre><h3><a class="nav-anchor" id="SimpleTree-1" href="#SimpleTree-1">SimpleTree</a></h3><p><a href="Tree.html#Hamiltonian.Utilities.Tree.SimpleTree"><code>SimpleTree{N,D}</code></a> is the minimum struct that implements all the default tree methods. You can include an instance of it as an attribute in your own type to utilize all the tree methods.</p><h2><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.treedepth" href="#Hamiltonian.Utilities.Tree.treedepth"><code>Hamiltonian.Utilities.Tree.treedepth</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">treedepth</code></pre><p>Indicate that the iteration over a tree is depth-first.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L21-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.treewidth" href="#Hamiltonian.Utilities.Tree.treewidth"><code>Hamiltonian.Utilities.Tree.treewidth</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">treewidth</code></pre><p>Indicate that the iteration over a tree is width-first.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L28-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.AbstractTree" href="#Hamiltonian.Utilities.Tree.AbstractTree"><code>Hamiltonian.Utilities.Tree.AbstractTree</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractTree{Node,Data}</code></pre><p>Abstract type for all concrete trees.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L35-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.SimpleTree" href="#Hamiltonian.Utilities.Tree.SimpleTree"><code>Hamiltonian.Utilities.Tree.SimpleTree</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SimpleTree{N,D}() where {N,D}</code></pre><p>The minimum tree structure that implements all the default tree methods.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L441-L445">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.TreeCore" href="#Hamiltonian.Utilities.Tree.TreeCore"><code>Hamiltonian.Utilities.Tree.TreeCore</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TreeCore()</code></pre><p>The core of a tree.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L355-L359">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.@tree" href="#Hamiltonian.Utilities.Tree.@tree"><code>Hamiltonian.Utilities.Tree.@tree</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@tree structdef treeparams::Union{Expr,Nothing}=nothing</code></pre><p>Decorate a &quot;raw&quot; struct to be a subtype of <code>AbstractTree</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ol><li>A &quot;raw&quot; struct means:<ul><li>It has no explicit supertype;</li><li>It has no inner constructor;</li><li>It has no attribute <code>:TREECORE</code>.</li></ul></li><li>The keytype and valtype can be assigned by the argument <code>treeparams</code> in the form <code>{keytype,valtype}</code>.<ul><li>When the formal argument names of keytype and valtype are not assigned, they can be automatically generated by the functioin <code>gensym</code>. For example, all of the structs after the decration by the following codes<pre><code class="language-julia">@tree struct SubTreeWithWrongTypeParameterNames{N} info::Vector{N} end
@tree struct SubTreeWithWrongTypeParameterNames{N} info::Vector{N} end {::String,::Int}
@tree struct SubTreeWithWrongTypeParameterNames{N} info::Vector{N} end {&lt;:AbstractString,&lt;:Number}</code></pre>will have three type parameters.</li><li>When the formal argument names of keytype and valtype overlap with those of the raw struct type parameters, the duplicates will be considered as the same. For example, the decorated struct <code>SubTreeWithOverlappedParametricFields</code> by the following code<pre><code class="language-julia">@tree struct SubTreeWithOverlappedParametricFields{N} info::Vector{N} end {N&lt;:AbstractString,D&lt;:Number}</code></pre>only has two type parameters <code>N&lt;:AbstractString</code> and <code>D&lt;:Number</code>, where the <code>N</code> in the <code>info::Vector{N}</code> is the same <code>N</code> with that in the decorated attribute <code>TREECORE::TreeCore{N,D}</code>.</li><li>When the formal argument names of keytype and valtype have no intersection with those of the raw struct type parameters, the type parameters of the decorated struct will be just extended by keytype and valtype. For example, the decorated struct <code>SubTreeWithParametricFields</code> by the following code<pre><code class="language-julia">@tree struct SubTreeWithParametricFields{T} info::Vector{T} end {N&lt;:AbstractString,D&lt;:Number}</code></pre>have 3 type parameters, <code>T</code>, <code>N&lt;:AbstractString</code> and <code>D&lt;:Number</code>.</li></ul></li></ol></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L377-L408">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.addnode!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N" href="#Hamiltonian.Utilities.Tree.addnode!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N"><code>Hamiltonian.Utilities.Tree.addnode!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addnode!(tree::AbstractTree{N,D},node::N) where {N,D} -&gt; typeof(tree)
addnode!(tree::AbstractTree{N,D},::Nothing,node::N) where {N,D} -&gt; typeof(tree)
addnode!(tree::AbstractTree{N,D},parent::N,node::N) where {N,D} -&gt; typeof(tree)</code></pre><p>Update the structure of a tree by adding a node. When the parent is <code>nothing</code>, the input tree must be empty and the input node becomes the tree&#39;s root.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L90-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.ancestor-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}, Tuple{AbstractTree{N,D},N,Int64}} where D where N" href="#Hamiltonian.Utilities.Tree.ancestor-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}, Tuple{AbstractTree{N,D},N,Int64}} where D where N"><code>Hamiltonian.Utilities.Tree.ancestor</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ancestor(tree::AbstractTree{N,D},node::N,generation::Int=1) where {N,D} -&gt; N</code></pre><p>Get the ancestor of a tree&#39;s node of the n-th generation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L242-L246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.children-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}" href="#Hamiltonian.Utilities.Tree.children-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}"><code>Hamiltonian.Utilities.Tree.children</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">children(tree::AbstractTree) -&gt; Vector{keytype(tree)}
children(tree::AbstractTree,::Nothing) -&gt; Vector{keytype(tree)}
children(tree::AbstractTree{N,D},node::N) where {N,D} -&gt; Vector{N}</code></pre><p>Get the children of a tree&#39;s node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L79-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.deletenode!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N" href="#Hamiltonian.Utilities.Tree.deletenode!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N"><code>Hamiltonian.Utilities.Tree.deletenode!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">deletenode!(tree::AbstractTree{N,D},node::N) where {N,D} -&gt; typeof(tree)</code></pre><p>Update the structure of a tree by deleting a node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L113-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.descendants-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}, Tuple{AbstractTree{N,D},N,Int64}} where D where N" href="#Hamiltonian.Utilities.Tree.descendants-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}, Tuple{AbstractTree{N,D},N,Int64}} where D where N"><code>Hamiltonian.Utilities.Tree.descendants</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">descendants(tree::AbstractTree{N,D},node::N,generation::Int=1) where {N,D} -&gt; Vector{N}</code></pre><p>Get the descendants of a tree&#39;s node of the n-th generation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L256-L260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.isleaf-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N" href="#Hamiltonian.Utilities.Tree.isleaf-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N"><code>Hamiltonian.Utilities.Tree.isleaf</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isleaf(tree::AbstractTree{N,D},node::N) where{N,D} -&gt; Bool</code></pre><p>Judge whether a tree&#39;s node is a leaf (a node without children) or not.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L221-L225">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.leaves-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}" href="#Hamiltonian.Utilities.Tree.leaves-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}"><code>Hamiltonian.Utilities.Tree.leaves</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">leaves(tree::AbstractTree) -&gt; Vector{keytype(tree)}</code></pre><p>Get a tree&#39;s leaves.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L277-L281">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.level-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N" href="#Hamiltonian.Utilities.Tree.level-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N"><code>Hamiltonian.Utilities.Tree.level</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">level(tree::AbstractTree{N,D},node::N) where {N,D} -&gt; Int</code></pre><p>Get the level of tree&#39;s node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L228-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.move!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N,N}} where D where N" href="#Hamiltonian.Utilities.Tree.move!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N,N}} where D where N"><code>Hamiltonian.Utilities.Tree.move!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">move!(tree::AbstractTree{N,D},node::N,parent::N) where {N,D} -&gt; typeof(tree)</code></pre><p>Move a subtree to a new position.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L343-L347">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.parent-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}, Tuple{AbstractTree{N,D},N,Union{Nothing, N}}} where D where N" href="#Hamiltonian.Utilities.Tree.parent-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}, Tuple{AbstractTree{N,D},N,Union{Nothing, N}}} where D where N"><code>Hamiltonian.Utilities.Tree.parent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">parent(tree::AbstractTree{N,D},node::N,superparent::Union{N,Nothing}=nothing) where {N,D} -&gt; Union{N,Nothing}</code></pre><p>Get the parent of a tree&#39;s node. When <code>node</code> is the tree&#39;s root, return <code>superparent</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L72-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.root-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}" href="#Hamiltonian.Utilities.Tree.root-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}"><code>Hamiltonian.Utilities.Tree.root</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">root(tree::AbstractTree) -&gt; Union{keytype(tree),Nothing}</code></pre><p>Get a tree&#39;s root node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L51-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.siblings-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N" href="#Hamiltonian.Utilities.Tree.siblings-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N"><code>Hamiltonian.Utilities.Tree.siblings</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">siblings(tree::AbstractTree{N,D},node::N) where{N,D} -&gt; Vector{N}</code></pre><p>Get the siblings (other nodes sharing the same parent) of a tree&#39;s node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L270-L274">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Tree.subtree-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N" href="#Hamiltonian.Utilities.Tree.subtree-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N"><code>Hamiltonian.Utilities.Tree.subtree</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">subtree(tree::AbstractTree{N,D},node::N) where{N,D} -&gt; typeof(tree)</code></pre><p>Get a subtree whose root is <code>node</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L330-L334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Union{Tuple{TC}, Tuple{TC,TC}} where TC&lt;:Hamiltonian.Utilities.Tree.TreeCore" href="#Base.:==-Union{Tuple{TC}, Tuple{TC,TC}} where TC&lt;:Hamiltonian.Utilities.Tree.TreeCore"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">==(tc1::TC,tc2::TC) where TC&lt;:TreeCore -&gt; Bool
isequal(tc1::TC,tc2::TC) where TC&lt;:TreeCore -&gt; Bool</code></pre><p>Overloaded equivalent operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L368-L373">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Hamiltonian.Utilities.Tree.AbstractTree" href="#Base.:==-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Hamiltonian.Utilities.Tree.AbstractTree"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">==(t1::T,t2::T) where T&lt;:AbstractTree -&gt; Bool
isequal(t1::T,t2::T) where T&lt;:AbstractTree -&gt; Bool</code></pre><p>Overloaded equivalent operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L174-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.append!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},AbstractTree{N,D}}} where D where N" href="#Base.append!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},AbstractTree{N,D}}} where D where N"><code>Base.append!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">append!(tree::AbstractTree{N,D},subtree::AbstractTree{N,D}) where {N,D} -&gt; typeof(tree)
append!(tree::AbstractTree{N,D},node::Union{N,Nothing},subtree::AbstractTree{N,D}) where {N,D} -&gt; typeof(tree)</code></pre><p>Append a subtree to a tree.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L297-L302">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.delete!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N" href="#Base.delete!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">delete!(tree::AbstractTree{N,D},node::N) where {N,D} -&gt; typeof(tree)</code></pre><p>Delete a node and all its descendants from a tree.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L311-L315">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eltype-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}" href="#Base.eltype-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">eltype(tree::AbstractTree)
eltype(::Type{&lt;:AbstractTree{N,D}}) where {N,D}</code></pre><p>Get the eltype of a tree.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L42-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.empty!-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}" href="#Base.empty!-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}"><code>Base.empty!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">empty!(tree::AbstractTree) -&gt; typeof(tree)</code></pre><p>Empty a tree.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L323-L327">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.empty-Union{Tuple{AbstractTree{N,D}}, Tuple{D}, Tuple{N}} where D where N" href="#Base.empty-Union{Tuple{AbstractTree{N,D}}, Tuple{D}, Tuple{N}} where D where N"><code>Base.empty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">empty(tree::AbstractTree)</code></pre><p>Construct an empty tree of the same type with the input one.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L146-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N" href="#Base.getindex-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getindex(tree::AbstractTree{N,D},node::N) where {N,D} -&gt; N</code></pre><p>Get the data of a tree&#39;s node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L132-L136">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.haskey-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N" href="#Base.haskey-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N}} where D where N"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">haskey(tree::AbstractTree{N,D},node::N) where {N,D} -&gt; Bool</code></pre><p>Check whether a node is in a tree.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L58-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.keys-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},TreeIteration}, Tuple{AbstractTree{N,D},TreeIteration,Union{Nothing, N}}} where D where N" href="#Base.keys-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},TreeIteration}, Tuple{AbstractTree{N,D},TreeIteration,Union{Nothing, N}}} where D where N"><code>Base.keys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">keys(tree::AbstractTree{N,D},::TreeDepth,node::Union{N,Nothing}=tree|&gt;root) where {N,D}
keys(tree::AbstractTree{N,D},::TreeWidth,node::Union{N,Nothing}=tree|&gt;root) where {N,D}</code></pre><p>Iterate over a tree&#39;s nodes starting from a certain <code>node</code> by depth first search or width first search.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L183-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.keytype-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}" href="#Base.keytype-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}"><code>Base.keytype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">keytype(tree::AbstractTree)
keytype(::Type{&lt;:AbstractTree{N,D}}) where {N,D}</code></pre><p>Get a tree&#39;s node type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L156-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}" href="#Base.length-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}"><code>Base.length</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">length(tree::AbstractTree) -&gt; Int</code></pre><p>Get the number of a tree&#39;s nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L65-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pairs-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree,TreeIteration}, Tuple{AbstractTree,TreeIteration,Union{Nothing, N}}} where D where N" href="#Base.pairs-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree,TreeIteration}, Tuple{AbstractTree,TreeIteration,Union{Nothing, N}}} where D where N"><code>Base.pairs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pairs(tree::AbstractTree,::TreeDepth,node::Union{N,Nothing}=tree|&gt;root) where {N,D}
pairs(tree::AbstractTree,::TreeWidth,node::Union{N,Nothing}=tree|&gt;root) where {N,D}</code></pre><p>Iterate over a tree&#39;s (node,data) pairs starting from a certain <code>node</code> by depth first search or width first search.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L213-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N,D}} where D where N" href="#Base.push!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},N,D}} where D where N"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">push!(tree::AbstractTree{N,D},node::N,data::D) where {N,D} -&gt; typeof(tree)
push!(tree::AbstractTree{N,D},parent::Union{N,Nothing},node::N,data::D) where {N,D} -&gt; typeof(tree)</code></pre><p>Push a new node to a tree. When <code>parent</code> is <code>nothing</code>, this function set the root node of an empty tree.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L284-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setindex!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},D,N}} where D where N" href="#Base.setindex!-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree{N,D},D,N}} where D where N"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">setindex!(tree::AbstractTree{N,D},data::D,node::N) where {N,D}</code></pre><p>Set the data of a tree&#39;s node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L139-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.valtype-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}" href="#Base.valtype-Tuple{Hamiltonian.Utilities.Tree.AbstractTree}"><code>Base.valtype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">valtype(tree::AbstractTree)
valtype(::Type{&lt;:AbstractTree{N,D}}) where {N,D}</code></pre><p>Get a tree&#39;s data type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L165-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.values-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree,TreeIteration}, Tuple{AbstractTree,TreeIteration,Union{Nothing, N}}} where D where N" href="#Base.values-Union{Tuple{D}, Tuple{N}, Tuple{AbstractTree,TreeIteration}, Tuple{AbstractTree,TreeIteration,Union{Nothing, N}}} where D where N"><code>Base.values</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">values(tree::AbstractTree,::TreeDepth,node::Union{N,Nothing}=tree|&gt;root) where {N,D}
values(tree::AbstractTree,::TreeWidth,node::Union{N,Nothing}=tree|&gt;root) where {N,D}</code></pre><p>Iterate over a tree&#39;s data starting from a certain <code>node</code> by depth first search or width first search.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/a168ddacd0d58c8224be270b01d1f96ae1a461af/src/Utilities/Tree.jl#L205-L210">source</a></section><footer><hr/><a class="previous" href="CompositeStructure.html"><span class="direction">Previous</span><span class="title">Composite structure</span></a><a class="next" href="NamedVector.html"><span class="direction">Next</span><span class="title">Named vector</span></a></footer></article></body></html>
