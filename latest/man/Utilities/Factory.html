<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Factory · Hamiltonian.jl</title><link rel="canonical" href="https://quantum-many-body.github.io/Hamiltonian.jl/latest/man/Utilities/Factory.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Hamiltonian.jl logo"/></a><h1>Hamiltonian.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">Home</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../../tutorial/Unitcell Description.html">Unitcell Description</a></li><li><a class="toctext" href="../../tutorial/Engine App Interface.html">Engine App Interface</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><span class="toctext">Utilities</span><ul><li><a class="toctext" href="Introduction.html">Introduction</a></li><li class="current"><a class="toctext" href="Factory.html">Factory</a><ul class="internal"><li><a class="toctext" href="#Inference-1">Inference</a></li><li><a class="toctext" href="#Argument-1">Argument</a></li><li><a class="toctext" href="#Parameter-1">Parameter</a></li><li><a class="toctext" href="#Field-1">Field</a></li><li><a class="toctext" href="#Block-1">Block</a></li><li><a class="toctext" href="#FunctionFactory-1">FunctionFactory</a></li><li><a class="toctext" href="#TypeFactory-1">TypeFactory</a></li><li><a class="toctext" href="#More-about-escape-1">More about escape</a></li><li><a class="toctext" href="#Manual-1">Manual</a></li></ul></li><li><a class="toctext" href="Tree.html">Tree</a></li><li><a class="toctext" href="NamedVector.html">Named vector</a></li><li><a class="toctext" href="GoodQuantumNumber.html">Good quantum numbers</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li>Utilities</li><li><a href="Factory.html">Factory</a></li></ul><a class="edit-page" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/master/docs/src/man/Utilities/Factory.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Factory</span><a class="fa fa-bars" href="#"></a></div></header><div></div><h1><a class="nav-anchor" id="Factory-1" href="#Factory-1">Factory</a></h1><p>The aim of <code>Factory</code> is to provide tools to hack into Julia codes without knowing the details of their abstract syntax trees and regularize the mechanism to &quot;escape&quot; variables in <code>Expr</code> expressions, so that users can manipulate the existing codes, modify them and generate new ones in macros. In particular, <code>Factory</code> in this module means the representation of certain blocks of Julia codes by a usual Julia struct. This representation is much easier to comprehend than the canonical <code>Expr</code> representation and makes it far more convenient to define macros. In general, we propose two basic requirements that any factory must satisfy:</p><ul><li><strong>FEATURE-1</strong>: A concrete factory can be constructed from a legal <code>Expr</code> expression that represents the block of codes it aims to represent;</li><li><strong>FEATURE-2</strong>: The canonical <code>Expr</code> expression of a block of codes that a concrete factory represents can be obtained by &quot;calling&quot; the factory itself.</li></ul><p>Also, we propose a simple mechanism to implement the escape of variables in factories:</p><ul><li><strong>FEATURE-3</strong>: During the construction from <code>Expr</code> expressions, a keyword argument <code>unescaped</code>, which is a tuple of <code>Symbol</code>s, can be passed to the constructor, and all variables whose names are not in this keyword argument will be escaped.</li></ul><p>Different from the former two requirements, this mechanism is just an optional feature of concrete factories. Meanwhile, all of these features also defines the basic interfaces to interact with factories.</p><p>Out of practical purposes, we implemente 7 kinds of factories, i.e. <em><a href="Factory.html#Hamiltonian.Utilities.Factory.Inference"><code>Inference</code></a></em>, <em><a href="Factory.html#Hamiltonian.Utilities.Factory.Argument"><code>Argument</code></a></em>, <em><a href="Factory.html#Hamiltonian.Utilities.Factory.Parameter"><code>Parameter</code></a></em>, <em><a href="Factory.html#Hamiltonian.Utilities.Factory.Field"><code>Field</code></a></em>, <em><a href="Factory.html#Hamiltonian.Utilities.Factory.Block"><code>Block</code></a></em>, <em><a href="Factory.html#Hamiltonian.Utilities.Factory.FunctionFactory"><code>FunctionFactory</code></a></em> and <em><a href="Factory.html#Hamiltonian.Utilities.Factory.TypeFactory"><code>TypeFactory</code></a></em>, which represent <em>a type inference</em>, <em>a function argument</em>, <em>a method or type parameter</em>, <em>a struct field</em>, <em>a <code>begin ... end</code> block</em>, <em>a function itself</em> and <em>a struct itself</em>, respectively. Some of the basic methods making the above requirements fulfilled with these types are based on the powerful functions defined in <a href="https://github.com/MikeInnes/MacroTools.jl"><code>MacroTools</code></a>.</p><h2><a class="nav-anchor" id="Inference-1" href="#Inference-1">Inference</a></h2><p>An <a href="Factory.html#Hamiltonian.Utilities.Factory.Inference"><code>Inference</code></a> has 4 attributes:</p><ul><li><code>head::Union{Symbol,Nothing}</code>: the head of the type inference, which must be one of <code>(nothing,:(::),:(&lt;:),:curly)</code></li><li><code>name::Union{Symbol,Nothing}</code>: the name of the type inference</li><li><code>params::Union{Inference,Vector{Inference},Nothing}</code>: the parameters of the type inference</li><li><code>escape::Bool</code>: whether the name of the type inference should be escaped when calling the factory</li></ul><p>All valid expressions representing type inferences can be passed to the constructor:</p><pre><code class="language-julia-repl">julia&gt; Inference(:T,unescaped=(:T,))
Inference(
  head:   nothing
  name:   T
  params: nothing
  escape: false
)

julia&gt; Inference(:(::T),unescaped=(:T,))
Inference(
  head:   ::
  name:   nothing
  params: T
  escape: false
)

julia&gt; Inference(:(&lt;:Number))
Inference(
  head:   &lt;:
  name:   nothing
  params: $(Expr(:escape, :Number))
  escape: false
)

julia&gt; Inference(:(Vector{T}),unescaped=(:T,))
Inference(
  head:   curly
  name:   Vector
  params: Inference[T]
  escape: true
)

julia&gt; Inference(:(Vector{Tuple{String,Int}}))
Inference(
  head:   curly
  name:   Vector
  params: Inference[($(Expr(:escape, :Tuple))){$(Expr(:escape, :String)), $(Expr(:escape, :Int))}]
  escape: true
)

julia&gt; Inference(:(Type{&lt;:Number}))
Inference(
  head:   curly
  name:   Type
  params: Inference[&lt;:$(Expr(:escape, :Number))]
  escape: true
)</code></pre><p>On the other hand, you can use the macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@inference"><code>@inference</code></a> to construct an <code>Inference</code> directly from a type inference:</p><pre><code class="language-julia-repl">julia&gt; @inference Vector{Tuple{String,Int}}
Inference(
  head:   curly
  name:   Vector
  params: Inference[($(Expr(:escape, :Tuple))){$(Expr(:escape, :String)), $(Expr(:escape, :Int))}]
  escape: true
)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ol><li><code>Inference</code> is a recursive struct, i.e. it recursively decomposes a type inference until the final type inference is just a <code>Symbol</code>.</li><li>When the input expression representing a type inference is a <code>Symbol</code>, the <code>head</code> and <code>params</code> attributes of the resulting <code>Inference</code> is <code>nothing</code>. Otherwise, its <code>head</code> is the same with that of the input expression, and the <code>args</code> of the input expression will be further decomposed, whose result will be stored in <code>params</code>.</li><li>When the head of the input expression is <code>:(::)</code> or <code>:(&lt;:)</code>, the <code>params</code> is an <code>Inference</code> whereas when the head of the input expression is <code>:curly</code>, the <code>params</code> is a <code>Vector{Inference}</code>.</li></ol></div></div><h2><a class="nav-anchor" id="Argument-1" href="#Argument-1">Argument</a></h2><p>An <a href="Factory.html#Hamiltonian.Utilities.Factory.Argument"><code>Argument</code></a> has 4 attributes:</p><ul><li><code>name::Union{Symbol,Nothing}</code>: the name of the argument</li><li><code>type::Inference</code>: the type inference of the argument</li><li><code>slurp::Bool</code>: whether the argument should be expanded by <code>...</code></li><li><code>default::Any</code>: the default value of the argument, <code>nothing</code> for those with no default values</li></ul><p>All valid expressions representing the arguments of functions can be passed to the constructor:</p><pre><code class="language-julia-repl">julia&gt; Argument(:arg)
Argument(
  name:    arg
  type:    $(Expr(:escape, :Any))
  slurp:   false
  default: nothing
)

julia&gt; Argument(:(arg::ArgType),unescaped=(:ArgType,))
Argument(
  name:    arg
  type:    ArgType
  slurp:   false
  default: nothing
)

julia&gt; Argument(:(arg::ArgType...),unescaped=(:ArgType,))
Argument(
  name:    arg
  type:    ArgType
  slurp:   true
  default: nothing
)

julia&gt; Argument(:(arg::ArgType=default),unescaped=(:ArgType,:default))
Argument(
  name:    arg
  type:    ArgType
  slurp:   false
  default: default
)</code></pre><p>Or you can use the macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@argument"><code>@argument</code></a> for construction directly from an argument declaration:</p><pre><code class="language-julia-repl">julia&gt; @argument arg::ArgType=default (:ArgType,:default)
Argument(
  name:    arg
  type:    ArgType
  slurp:   false
  default: default
)</code></pre><p>The construction from such expressions is based on the the <code>MacroTools.splitarg</code> function. On the other hand, calling an instance of <code>Argument</code> will get the corresponding <code>Expr</code> expression, e.g.,</p><pre><code class="language-julia-repl">julia&gt; Argument(:(arg::ArgType=default),unescaped=(:ArgType,:default))()
:(arg::ArgType=default)</code></pre><p>This feature is based on the <code>MacroTools.combinearg</code> function.</p><h2><a class="nav-anchor" id="Parameter-1" href="#Parameter-1">Parameter</a></h2><p>A <a href="Factory.html#Hamiltonian.Utilities.Factory.Parameter"><code>Parameter</code></a> has 2 attributes:</p><ul><li><code>name::Union{Symbol,Nothing}</code>: the name of the parameter</li><li><code>type::Union{Inference,Nothing}</code>: the type inference of the parameter</li></ul><p>All expressions that represent a type parameter or a method parameter are allowed to be passed to the constructor:</p><pre><code class="language-julia-repl">julia&gt; Parameter(:T)
Parameter(
  name: T
  type: nothing
)

julia&gt; Parameter(:(&lt;:Number))
Parameter(
  name: nothing
  type: $(Expr(:escape, :Number))
)

julia&gt; Parameter(:(T&lt;:Number))
Parameter(
  name: T
  type: $(Expr(:escape, :Number))
)

julia&gt; Parameter(:(::Int))
Parameter(
  name: nothing
  type: $(Expr(:escape, :Int))
)</code></pre><p>The macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@parameter"><code>@parameter</code></a> completes the construction directly from a parameter declaration:</p><pre><code class="language-julia-repl">julia&gt; @parameter T&lt;:Number
Parameter(
  name: T
  type: $(Expr(:escape, :Number))
)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ol><li>We use <code>nothing</code> to denote a missing <code>name</code> or <code>type.</code></li><li>Two subtle situations of type/method parameters, e.g. <code>MyType{T}</code> and <code>MyType{Int}</code>, are distinguished by <code>Parameter(:T)</code> and <code>Parameter(:(::Int))</code>. For the first case, <code>Parameter(:T).name==:T</code> and <code>Parameter(:T).type==:nothing</code> while for the second case, <code>Parameter(:(::Int)).name==:nothing</code> and <code>Parameter(:(::Int)).name==:Int</code>. Moreover, the callings of them return different forms, e.g. <code>Parameter(:T)()==:T</code> and <code>Parameter(:(::Int))==:(&lt;:$(esc(Int)))</code>.</li></ol></div></div><h2><a class="nav-anchor" id="Field-1" href="#Field-1">Field</a></h2><p>A <a href="Factory.html#Hamiltonian.Utilities.Factory.Field"><code>Field</code></a> has 2 attributes:</p><ul><li><code>name::Symbol</code>: the name of the field</li><li><code>type::Inference</code>: the type inference of the field</li></ul><p>Legal expressions can be used to construct a <code>Field</code> instance by its constructor:</p><pre><code class="language-julia-repl">julia&gt; Field(:field)
Field(
  name: field
  type: $(Expr(:escape, :Any))
)

julia&gt; Field(:(field::FieldType),unescaped=(:FieldType,))
Field(
  name: field
  type: FieldType
)

julia&gt; Field(:(field::ParametricType{T}),unescaped=(:ParametricType,:T))
Field(
  name: field
  type: ParametricType{T}
)</code></pre><p>The macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@field"><code>@field</code></a> is also provided to help the construction directly from a field declaration:</p><pre><code class="language-julia-repl">julia&gt; @field field::FieldType (:FieldType,)
Field(
  name: field
  type: FieldType
)</code></pre><p>The construction from these expressions is based on the <code>MacroTools.splitarg</code> function and the convertion to these expressions is based on the <code>MacroTools.combinefield</code> function.</p><h2><a class="nav-anchor" id="Block-1" href="#Block-1">Block</a></h2><p>A <a href="Factory.html#Hamiltonian.Utilities.Factory.Block"><code>Block</code></a> has only one attribute:</p><ul><li><code>body::Vector{Any}</code>: the body of the <code>begin ... end</code> block</li></ul><p>Any expression can be passed to the constructor of <code>Block</code>:</p><pre><code class="language-julia-repl">julia&gt; Block(:(x=1))
Block(
  body: Any[:(x = 1)]
)

julia&gt; Block(:(x=1;y=2))
Block(
  body: Any[:(x = 1), :(#= none:1 =#), :(y = 2)]
)

julia&gt; Block(:(begin x=1 end))
Block(
  body: Any[:(#= none:1 =#), :(x = 1)]
)

julia&gt; Block(quote
               x=1
               y=2
           end)
Block(
  body: Any[:(#= none:2 =#), :(x = 1), :(#= none:3 =#), :(y = 2)]
)</code></pre><p>Or you can construct a <code>Block</code> instance directly from any code by the macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@block-Tuple{Vararg{Union{Expr, Symbol},N} where N}"><code>@block</code></a>:</p><pre><code class="language-julia-repl">julia&gt; @block x=1 y=2
Block(
  body: Any[:(x = 1), :(y = 2)]
)</code></pre><p>The body of a <code>block</code> can also be extended by the <a href="Factory.html#Base.push!-Tuple{Hamiltonian.Utilities.Factory.Block}"><code>push!</code></a> function or the <a href="Factory.html#Hamiltonian.Utilities.Factory.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@push!</code></a> macro.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ol><li>The body of a <code>Block</code> is somewhat &quot;flattened&quot;, i.e. it contains no <code>begin ... end</code> blocks. During the initialization, any such input block will be unblocked and added to the body part by part. So is the <a href="Factory.html#Base.push!-Tuple{Hamiltonian.Utilities.Factory.Block}"><code>push!</code></a> and <a href="Factory.html#Hamiltonian.Utilities.Factory.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@push!</code></a> processes.</li><li>All <code>LineNumberNode</code>s generated by the input codes will also be included in the block&#39;s body. However, you can use <a href="Factory.html#Hamiltonian.Utilities.Factory.rmlines!-Tuple{Hamiltonian.Utilities.Factory.Block}"><code>rmlines!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@rmlines!-Tuple{Expr}"><code>@rmlines!</code></a> to remove them from the body of an existing <code>Block</code>, or use <a href="Factory.html#MacroTools.rmlines-Tuple{Hamiltonian.Utilities.Factory.Block}"><code>rmlines</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@rmlines-Tuple{Expr}"><code>@rmlines</code></a> to get a copy with them removed in the body.</li><li><code>Block</code> is the only factory that <strong>DOES NOT</strong> cope with the &quot;escape&quot; mechanism we propose, because usually variables in a block are local ones and should not be escaped. However, the function <a href="Factory.html#Hamiltonian.Utilities.Factory.escape-Union{Tuple{Any}, Tuple{N}, Tuple{Any,Tuple{Vararg{Symbol,N}}}} where N"><code>escape</code></a> is provided to escape the variables in a <code>Expr</code> expression with a reverse mechanism, where a tuple of variables to be escaped should be transmitted.</li></ol></div></div><h2><a class="nav-anchor" id="FunctionFactory-1" href="#FunctionFactory-1">FunctionFactory</a></h2><p>A <a href="Factory.html#Hamiltonian.Utilities.Factory.FunctionFactory"><code>FunctionFactory</code></a> has 6 attributes:</p><ul><li><code>name::Symbol</code>: the name of the function</li><li><code>args::Vector{Argument}</code>: the positional arguments of the function</li><li><code>kwargs::Vector{Argument}</code>: the keyword arguments of the function</li><li><code>rtype::Inference</code>: the return type of the function</li><li><code>params::Vector{Parameter}</code>: the method parameters specified by the <code>where</code> keyword</li><li><code>body::Block</code>: the body of the function</li></ul><p>All expressions that represent functions are allowed to be passed to the constructor:</p><pre><code class="language-julia-repl">julia&gt; FunctionFactory(:(f()=nothing))
FunctionFactory(
  name:   f
  args:   Argument[]
  kwargs: Argument[]
  rtype:  $(Expr(:escape, :Any))
  params: Parameter[]
  body:   begin
              nothing
          end
)

julia&gt; FunctionFactory(:(f(x)=x))
FunctionFactory(
  name:   f
  args:   Argument[x::$(Expr(:escape, :Any))]
  kwargs: Argument[]
  rtype:  $(Expr(:escape, :Any))
  params: Parameter[]
  body:   begin
              x
          end
)

julia&gt; FunctionFactory(:(f(x::Int,y::Int;choice::Function=sum)=choice(x,y)))
FunctionFactory(
  name:   f
  args:   Argument[x::$(Expr(:escape, :Int)), y::$(Expr(:escape, :Int))]
  kwargs: Argument[choice::$(Expr(:escape, :Function))=$(Expr(:escape, :sum))]
  rtype:  $(Expr(:escape, :Any))
  params: Parameter[]
  body:   begin
              choice(x, y)
          end
)

julia&gt; FunctionFactory(:(f(x::T,y::T;choice::Function=sum) where T&lt;:Number=choice(x,y)),unescaped=(:T,))
FunctionFactory(
  name:   f
  args:   Argument[x::T, y::T]
  kwargs: Argument[choice::$(Expr(:escape, :Function))=$(Expr(:escape, :sum))]
  rtype:  $(Expr(:escape, :Any))
  params: Parameter[T &lt;: $(Expr(:escape, :Number))]
  body:   begin
              choice(x, y)
          end
)

julia&gt; FunctionFactory(:((f(x::T,y::T;choice::Function=sum)::T) where T&lt;:Number=choice(x,y)),unescaped=(:T,))
FunctionFactory(
  name:   f
  args:   Argument[x::T, y::T]
  kwargs: Argument[choice::$(Expr(:escape, :Function))=$(Expr(:escape, :sum))]
  rtype:  T
  params: Parameter[T &lt;: $(Expr(:escape, :Number))]
  body:   begin
              choice(x, y)
          end
)

julia&gt; FunctionFactory(:(
           function (f(x::T,y::T;choice::Function=sum)::T) where T&lt;:Number
               choice(x,y)
           end
           ),
           unescaped=(:T,)
       )
FunctionFactory(
  name:   f
  args:   Argument[x::T, y::T]
  kwargs: Argument[choice::$(Expr(:escape, :Function))=$(Expr(:escape, :sum))]
  rtype:  T
  params: Parameter[T &lt;: $(Expr(:escape, :Number))]
  body:   begin
              #= none:3 =#
              choice(x, y)
          end
)

julia&gt; FunctionFactory(
           quote
               function (f(x::T,y::T;choice::Function=sum)::T) where T&lt;:Number
                   choice(x,y)
               end
           end,
           unescaped=(:T,)
       )
FunctionFactory(
  name:   f
  args:   Argument[x::T, y::T]
  kwargs: Argument[choice::$(Expr(:escape, :Function))=$(Expr(:escape, :sum))]
  rtype:  T
  params: Parameter[T &lt;: $(Expr(:escape, :Number))]
  body:   begin
              #= none:4 =#
              choice(x, y)
          end
)</code></pre><p>Similarly, an instance can also be constructed from the macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@functionfactory"><code>@functionfactory</code></a>:</p><pre><code class="language-julia-repl">julia&gt; @functionfactory (f(x::T,y::T;choice::Function=sum)::T) where T&lt;:Number=choice(x,y) (:T,)
FunctionFactory(
  name:   f
  args:   Argument[x::T, y::T]
  kwargs: Argument[choice::$(Expr(:escape, :Function))=$(Expr(:escape, :sum))]
  rtype:  T
  params: Parameter[T &lt;: $(Expr(:escape, :Number))]
  body:   begin
              choice(x, y)
          end
)</code></pre><p>The construction from and the convertion to such expressions are based on the <code>MacroTools.splitdef</code> and <code>MacroTools.combinedef</code> functions, respectively.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Because the form <code>f{T}(x::T,y::T;choice::Function=sum)</code> has no longer been supported since Julia 0.7, the entry <code>:params</code> in the returned dict by <code>MacroTools.splitarg</code> is always missing. Therefore, we abandon its corresponding field in <code>FunctionFactory</code> but use the attribute <code>:params</code> to denote the <code>:whereparams</code> entry.</p></div></div><p>Other features include:</p><ul><li>Positional arguments can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}"><code>addargs!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addargs!</code></a></li><li>Keyword arguments can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addkwargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}"><code>addkwargs!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addkwargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addkwargs!</code></a></li><li>Method parameters can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addparams!-Tuple{Union{FunctionFactory, TypeFactory}}"><code>addparams!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addparams!</code></a></li><li>Body can be extended by <a href="Factory.html#Hamiltonian.Utilities.Factory.extendbody!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}"><code>extendbody!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@extendbody!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@extendbody!</code></a></li></ul><h2><a class="nav-anchor" id="TypeFactory-1" href="#TypeFactory-1">TypeFactory</a></h2><p>A <a href="Factory.html#Hamiltonian.Utilities.Factory.TypeFactory"><code>TypeFactory</code></a> has 6 attributes:</p><ul><li><code>name::Symbol</code>: the name of the struct</li><li><code>mutable::Bool</code>: whether or not the struct is mutable</li><li><code>params::Vector{Parameter}</code>: the type parameters of the struct</li><li><code>supertype::Inference</code>: the supertype of the struct</li><li><code>fields::Vector{Field}</code>: the fields of the struct</li><li><code>constructors::Vector{FunctionFactory}</code>: the inner constructors of the struct</li></ul><p>Any expression representing valid struct definitions can be passed to the constructor:</p><pre><code class="language-julia-repl">julia&gt; TypeFactory(:(struct StructName end))
TypeFactory(
  name:         StructName
  mutable:      false
  params:       Parameter[]
  supertype:    $(Expr(:escape, :Any))
  fields:       Field[]
  constructors: FunctionFactory[]
)

julia&gt; TypeFactory(:(struct StructName{T} end),unescaped=(:T,))
TypeFactory(
  name:         StructName
  mutable:      false
  params:       Parameter[T]
  supertype:    $(Expr(:escape, :Any))
  fields:       Field[]
  constructors: FunctionFactory[]
)

julia&gt; TypeFactory(:(struct Child{T} &lt;: Parent{T} end),unescaped=(:T,))
TypeFactory(
  name:         Child
  mutable:      false
  params:       Parameter[T]
  supertype:    ($(Expr(:escape, :Parent))){T}
  fields:       Field[]
  constructors: FunctionFactory[]
)

julia&gt; TypeFactory(:(
           struct Child{T&lt;:Number} &lt;: Parent{T}
               field1::T
               field2::T
           end
           ),
           unescaped=(:T,)
       )
TypeFactory(
  name:         Child
  mutable:      false
  params:       Parameter[T &lt;: $(Expr(:escape, :Number))]
  supertype:    ($(Expr(:escape, :Parent))){T}
  fields:       Field[field1::T, field2::T]
  constructors: FunctionFactory[]
)

julia&gt; TypeFactory(
           quote
               struct Child{T&lt;:Number} &lt;: Parent{T}
                   field1::T
                   field2::T
               end
           end,
           unescaped=(:T,)
       )
TypeFactory(
  name:         Child
  mutable:      false
  params:       Parameter[T &lt;: $(Expr(:escape, :Number))]
  supertype:    ($(Expr(:escape, :Parent))){T}
  fields:       Field[field1::T, field2::T]
  constructors: FunctionFactory[]
)</code></pre><p>Also, the macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@typefactory"><code>@typefactory</code></a> supports the construction directly from a type definition:</p><pre><code class="language-julia-repl">julia&gt; @typefactory struct Child{T&lt;:Number} &lt;: Parent{T} field1::T; field2::T; Child(field1::T,field2::T=zero(T)) where T=new{T}(field1,field2) end (:T,)
TypeFactory(
  name:         Child
  mutable:      false
  params:       Parameter[T &lt;: $(Expr(:escape, :Number))]
  supertype:    ($(Expr(:escape, :Parent))){T}
  fields:       Field[field1::T, field2::T]
  constructors: FunctionFactory[
                  function (Child(field1::T, field2::T=($(Expr(:escape, :zero)))(T); )::$(Expr(:escape, :Any))) where T
                      #= /home/travis/.julia/packages/MacroTools/4AjBS/src/utils.jl:302 =#
                      begin
                          new{T}(field1, field2)
                      end
                  end
                  ]
)</code></pre><p>The construction from these expressions is based on the <code>MacroTools.splitstructdef</code> function. Meanwhile, the convertion to the corresponding expression from a <code>TypeFactory</code> is based on the <code>MacroTools.combinestructdef</code> function.</p><p>Other features include:</p><ul><li>Fields can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addfields!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory}"><code>addfields!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addfields!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addfields!</code></a></li><li>Type parameters can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addparams!-Tuple{Union{FunctionFactory, TypeFactory}}"><code>addparams!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addparams!</code></a></li><li>Inner constructors can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addconstructors!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory}"><code>addconstructors!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addconstructors!-Tuple{Any,Vararg{Expr,N} where N}"><code>@addconstructors!</code></a></li></ul><h2><a class="nav-anchor" id="More-about-escape-1" href="#More-about-escape-1">More about escape</a></h2><p>As you may have noticed, during the construction of factoies, we often provide a keyword argument <code>unescaped</code> to tell what variables should not be escaped. The criterion to determine such variables is quite direct and simple: if a variable is local to current module, or to be defined, or to be declared, it should not be escaped, while if it has been defined or declared in other modules, it should be escaped. Therefore, the name of a function argument, or a type/method parameter, or a struct field, should not be escaped because the first is a local variable and the latter two are to-be-declared ones. In fact, by design, these names will <strong>NEVER</strong> be escaped even when they are not provided in the <code>unescaped</code> keyword argument. Another common situation where unescaped variables exist occurs when methods or structs have parameters. In this case, the type inferences specified by these method/type parameters should not be escaped because they are also local ones. Note that this situation is not automatically handled by the above factories, because the method/type parameters can be modified after the factoies are constructed, which means, you have to offer the <code>unescaped</code> tuple by hand. To help decorate existing methods or structs, we define an inquiry function <a href="Factory.html#Hamiltonian.Utilities.Factory.paramnames-Tuple{Union{FunctionFactory, TypeFactory}}"><code>paramnames</code></a> to obtain the method/type parameter names. By the way, the factory <a href="Factory.html#Hamiltonian.Utilities.Factory.Block"><code>Block</code></a> does not support variable escape by design, because it is usually used as the body of a function, which is always a local environment. This is in sharp contrast to the method/type declaration, where type inferences are usually involved with variables that are defined or declared in other modules. This also explains the philosophy behind our design that for such factories, variables that are not escaped should be assigned while for the function <a href="Factory.html#Hamiltonian.Utilities.Factory.escape-Union{Tuple{Any}, Tuple{N}, Tuple{Any,Tuple{Vararg{Symbol,N}}}} where N"><code>escape</code></a>, variables to be escaped should be assigned.</p><h2><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.FExpr" href="#Hamiltonian.Utilities.Factory.FExpr"><code>Hamiltonian.Utilities.Factory.FExpr</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Factory expression types, which is defined as <code>Union{Symbol,Expr}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Argument" href="#Hamiltonian.Utilities.Factory.Argument"><code>Hamiltonian.Utilities.Factory.Argument</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Argument(name::Union{Symbol,Nothing},type::Inference,slurp::Bool,default::Any)
Argument(;name::Union{Symbol,Nothing}=nothing,type::Inference=Inference(:Any),slurp::Bool=false,default::Any=nothing)
Argument(expr::FExpr;unescaped::NTuple{N,Symbol}=()) where N)</code></pre><p>The struct to describe a argument of a <code>function</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L183-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Argument-Tuple{}" href="#Hamiltonian.Utilities.Factory.Argument-Tuple{}"><code>Hamiltonian.Utilities.Factory.Argument</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(a::Argument)()</code></pre><p>Convert an <code>Argument</code> to the <code>Expr</code> representation of the argument it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L209-L213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Block" href="#Hamiltonian.Utilities.Factory.Block"><code>Hamiltonian.Utilities.Factory.Block</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Block(parts::FExpr...)</code></pre><p>The struct to describe a <code>begin ... end</code> block.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L294-L298">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Block-Tuple{}" href="#Hamiltonian.Utilities.Factory.Block-Tuple{}"><code>Hamiltonian.Utilities.Factory.Block</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(b::Block)()</code></pre><p>Convert a <code>Block</code> to the <code>Expr</code> representation of the <code>begin ... end</code> block it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L311-L315">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Field" href="#Hamiltonian.Utilities.Factory.Field"><code>Hamiltonian.Utilities.Factory.Field</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Field(name::Symbol,type::Inference)
Field(name::Symbol;type::FExpr=Inference(:Any))
Field(expr::Expr;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>The struct to describe a field of a <code>struct</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L257-L263">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Field-Tuple{}" href="#Hamiltonian.Utilities.Factory.Field-Tuple{}"><code>Hamiltonian.Utilities.Factory.Field</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(f::Field)()</code></pre><p>Convert a <code>Field</code> to the <code>Expr</code> representation of the field it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L278-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.FunctionFactory" href="#Hamiltonian.Utilities.Factory.FunctionFactory"><code>Hamiltonian.Utilities.Factory.FunctionFactory</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FunctionFactory(name::Symbol,args::Vector{Argument},kwargs::Vector{Argument},rtype::Inference,params::Vector{Parameter},body::Block)
FunctionFactory(    name::Symbol;
                    args::Vector{Argument}=Argument[],
                    kwargs::Vector{Argument}=Argument[],
                    rtype::Inference=Inference(:Any),
                    params::Vector{Parameter}=Parameter[],
                    body::Block=Block()
                    )
FunctionFactory(expr::Expr;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>The struct to describe a <code>function</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L367-L379">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.FunctionFactory-Tuple{}" href="#Hamiltonian.Utilities.Factory.FunctionFactory-Tuple{}"><code>Hamiltonian.Utilities.Factory.FunctionFactory</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(ff::FunctionFactory)()</code></pre><p>Convert a <code>FunctionFactory</code> to the <code>Expr</code> representation of the <code>function</code> it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L415-L419">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Inference" href="#Hamiltonian.Utilities.Factory.Inference"><code>Hamiltonian.Utilities.Factory.Inference</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Inference(head::Union{Symbol,Nothing},name::Union{Symbol,Nothing},params::Union{Inference,Vector{Inference},Nothing},escape::Bool)
Inference(;
        head::Union{Symbol,Nothing}=nothing,
        name::Union{Symbol,Nothing}=nothing,
        params::Union{Inference,Vector{Inference},Nothing}=nothing,
        escape::Bool=true
        )
Inference(expr::FExpr;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>The struct to describe a type inference.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L120-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Inference-Tuple{}" href="#Hamiltonian.Utilities.Factory.Inference-Tuple{}"><code>Hamiltonian.Utilities.Factory.Inference</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(i::Inference)()</code></pre><p>Convert a <code>Inference</code> to the <code>Expr</code> representation of the type inference it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L168-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Parameter" href="#Hamiltonian.Utilities.Factory.Parameter"><code>Hamiltonian.Utilities.Factory.Parameter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Parameter(name::Union{Symbol,Nothing},type::Union{Inference,Nothing})
Parameter(;name::Union{Symbol,Nothing}=nothing,type::Union{Inference,Nothing}=nothing)
Parameter(expr::FExpr;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>The struct to describe a parameter of a <code>function</code> or a <code>type</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L216-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Parameter-Tuple{}" href="#Hamiltonian.Utilities.Factory.Parameter-Tuple{}"><code>Hamiltonian.Utilities.Factory.Parameter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(p::Parameter)()</code></pre><p>Convert a <code>Parameter</code> to the <code>Expr</code> representation of the parameter it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L250-L254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.TypeFactory" href="#Hamiltonian.Utilities.Factory.TypeFactory"><code>Hamiltonian.Utilities.Factory.TypeFactory</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TypeFactory(name::Symbol,mutable::Bool,params::Vector{Parameter},supertype::Inference,fields::Vector{Field},constructors::Vector{FunctionFactory})
TypeFactory(    name::Symbol;
                mutable::Bool=false,
                params::Vector{Parameter}=Parameter[],
                supertype::Inference=Inference(:Any),
                fields::Vector{Field}=Field[],
                constructors::Vector{FunctionFactory}=FunctionFactory[],
                )
TypeFactory(expr::Expr;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>The struct to describe a <code>struct</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L482-L494">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.TypeFactory-Tuple{}" href="#Hamiltonian.Utilities.Factory.TypeFactory-Tuple{}"><code>Hamiltonian.Utilities.Factory.TypeFactory</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(tf::TypeFactory)()</code></pre><p>Convert a <code>TypeFactory</code> to the <code>Expr</code> representation of the <code>struct</code> it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L530-L534">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@addargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@addargs!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addargs! ff args::FExpr...</code></pre><p>Add a couple of positional arguments to a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L441-L445">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addconstructors!-Tuple{Any,Vararg{Expr,N} where N}" href="#Hamiltonian.Utilities.Factory.@addconstructors!-Tuple{Any,Vararg{Expr,N} where N}"><code>Hamiltonian.Utilities.Factory.@addconstructors!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addconstructors! tf constructors::Expr...</code></pre><p>Add a couple of constructors to a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L573-L577">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addfields!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@addfields!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@addfields!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addfields! tf fields::FExpr...</code></pre><p>Add a couple of fields to a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L556-L560">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addkwargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@addkwargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@addkwargs!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addkwargs! ff kwargs::FExpr...</code></pre><p>Add a couple of keyword arguments to a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L458-L462">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@addparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@addparams!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addparams! f params::FExpr...</code></pre><p>Add a couple of method parameters to a function factory or a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L590-L594">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@argument" href="#Hamiltonian.Utilities.Factory.@argument"><code>Hamiltonian.Utilities.Factory.@argument</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@argument expr::FExpr unescaped::FExpr=:()</code></pre><p>Construct an <code>Argument</code> directly from an argument statement.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L202-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@block-Tuple{Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@block-Tuple{Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@block</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@block parts::FExpr...</code></pre><p>Construct a <code>Block</code> directly from a <code>begin ... end</code> block definition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L304-L308">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@extendbody!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@extendbody!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@extendbody!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@extendbody! ff parts::FExpr...</code></pre><p>Extend the body of a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L475-L479">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@field" href="#Hamiltonian.Utilities.Factory.@field"><code>Hamiltonian.Utilities.Factory.@field</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@field expr::FExpr unescaped::FExpr=:()</code></pre><p>Construct a <code>Field</code> directly from a field statement.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L271-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@functionfactory" href="#Hamiltonian.Utilities.Factory.@functionfactory"><code>Hamiltonian.Utilities.Factory.@functionfactory</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@functionfactory expr::FExpr unescaped::FExpr=:()</code></pre><p>Construct a <code>FunctionFactory</code> directly from a function definition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L408-L412">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@inference" href="#Hamiltonian.Utilities.Factory.@inference"><code>Hamiltonian.Utilities.Factory.@inference</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@inference expr::FExpr unescaped::FExpr=:()</code></pre><p>Construct an <code>Inference</code> directly from a type inference.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L161-L165">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@parameter" href="#Hamiltonian.Utilities.Factory.@parameter"><code>Hamiltonian.Utilities.Factory.@parameter</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@parameter expr::FExpr unescaped::FExpr=:()</code></pre><p>Construct a <code>Parameter</code> directly from an parameter statement.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L243-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@push!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@push! b parts::FExpr...</code></pre><p>Push other parts into the body of a block.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L332-L336">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@rmlines!-Tuple{Expr}" href="#Hamiltonian.Utilities.Factory.@rmlines!-Tuple{Expr}"><code>Hamiltonian.Utilities.Factory.@rmlines!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@rmlines! b::Expr</code></pre><p>Remove line number nodes in the body of a block.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L346-L350">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@rmlines-Tuple{Expr}" href="#Hamiltonian.Utilities.Factory.@rmlines-Tuple{Expr}"><code>Hamiltonian.Utilities.Factory.@rmlines</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@rmlines b::Expr</code></pre><p>Return a copy of a block with the line number nodes removed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L360-L364">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@typefactory" href="#Hamiltonian.Utilities.Factory.@typefactory"><code>Hamiltonian.Utilities.Factory.@typefactory</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@typefactory expr::Expr unescaped::FExpr=:()</code></pre><p>Construct a <code>TypeFactory</code> directly from a type definition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L523-L527">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}" href="#Hamiltonian.Utilities.Factory.addargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}"><code>Hamiltonian.Utilities.Factory.addargs!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addargs!(ff::FunctionFactory,args::Argument...)
addargs!(ff::FunctionFactory,args::FExpr...;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>Add a couple of positional arguments to a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L431-L436">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addconstructors!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory}" href="#Hamiltonian.Utilities.Factory.addconstructors!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory}"><code>Hamiltonian.Utilities.Factory.addconstructors!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addconstructors!(tf::TypeFactory,constructors::FunctionFactory...)
addconstructors!(tf::TypeFactory,constructors::Expr...;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>Add a couple of constructors to a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L563-L568">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addfields!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory}" href="#Hamiltonian.Utilities.Factory.addfields!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory}"><code>Hamiltonian.Utilities.Factory.addfields!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addfields!(tf::TypeFactory,fields::Field...)
addfields!(tf::TypeFactory,fields::FExpr...;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>Add a couple of fields to a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L546-L551">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addkwargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}" href="#Hamiltonian.Utilities.Factory.addkwargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}"><code>Hamiltonian.Utilities.Factory.addkwargs!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addkwargs!(ff::FunctionFactory,kwargs::Argument...)
addkwargs!(ff::FunctionFactory,kwargs::FExpr...;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>Add a couple of keyword arguments to a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L448-L453">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addparams!-Tuple{Union{FunctionFactory, TypeFactory}}" href="#Hamiltonian.Utilities.Factory.addparams!-Tuple{Union{FunctionFactory, TypeFactory}}"><code>Hamiltonian.Utilities.Factory.addparams!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addparams!(f::Union{FunctionFactory,TypeFactory},params::Parameter...)
addparams!(f::Union{FunctionFactory,TypeFactory},params::FExpr...;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>Add a couple of method parameters to a function factory or a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L580-L585">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.escape-Union{Tuple{Any}, Tuple{N}, Tuple{Any,Tuple{Vararg{Symbol,N}}}} where N" href="#Hamiltonian.Utilities.Factory.escape-Union{Tuple{Any}, Tuple{N}, Tuple{Any,Tuple{Vararg{Symbol,N}}}} where N"><code>Hamiltonian.Utilities.Factory.escape</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">escape(expr,::NTuple{N,Symbol}=()) where N
escape(expr::Symbol,escaped::NTuple{N,Symbol}=()) where N
escape(expr::Expr,escaped::NTuple{N,Symbol}=()) where N</code></pre><p>Escape the symbols sepecified by <code>escaped</code> in the input expression.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L48-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.extendbody!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}" href="#Hamiltonian.Utilities.Factory.extendbody!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}"><code>Hamiltonian.Utilities.Factory.extendbody!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">extendbody!(ff::FunctionFactory,parts::FExpr...)
extendbody!(ff::FunctionFactory,parts::Block...)</code></pre><p>Extend the body of a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L465-L470">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.paramnames-Tuple{Union{FunctionFactory, TypeFactory}}" href="#Hamiltonian.Utilities.Factory.paramnames-Tuple{Union{FunctionFactory, TypeFactory}}"><code>Hamiltonian.Utilities.Factory.paramnames</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">paramnames(expr::Union{Expr,FunctionFactory,TypeFactory}) -&gt; NTuple{N,Symbol} where N</code></pre><p>Get the type/method parameters names.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L597-L601">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.rmlines!-Tuple{Hamiltonian.Utilities.Factory.Block}" href="#Hamiltonian.Utilities.Factory.rmlines!-Tuple{Hamiltonian.Utilities.Factory.Block}"><code>Hamiltonian.Utilities.Factory.rmlines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rmlines!(b::Block)</code></pre><p>Remove line number nodes in the body of a block.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L339-L343">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.symbols-Tuple{Any}" href="#Hamiltonian.Utilities.Factory.symbols-Tuple{Any}"><code>Hamiltonian.Utilities.Factory.symbols</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">symbols(expr)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L33-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.rmlines-Tuple{Hamiltonian.Utilities.Factory.Block}" href="#MacroTools.rmlines-Tuple{Hamiltonian.Utilities.Factory.Block}"><code>MacroTools.rmlines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rmlines(b::Block)</code></pre><p>Return a copy of a block with the line number nodes removed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L353-L357">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.AbstractFactory" href="#Hamiltonian.Utilities.Factory.AbstractFactory"><code>Hamiltonian.Utilities.Factory.AbstractFactory</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractFactory</code></pre><p>Abstract type for all concrete factories.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L59-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Union{Tuple{F}, Tuple{F,F}} where F&lt;:Hamiltonian.Utilities.Factory.AbstractFactory" href="#Base.:==-Union{Tuple{F}, Tuple{F,F}} where F&lt;:Hamiltonian.Utilities.Factory.AbstractFactory"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">==(f1::F,f2::F) where F&lt;:AbstractFactory</code></pre><p>Overloaded <code>==</code> operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L66-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.broadcasted-Union{Tuple{N}, Tuple{Type{#s62} where #s62&lt;:AbstractFactory,Array{Union{Expr, Symbol},1}}} where N" href="#Base.Broadcast.broadcasted-Union{Tuple{N}, Tuple{Type{#s62} where #s62&lt;:AbstractFactory,Array{Union{Expr, Symbol},1}}} where N"><code>Base.Broadcast.broadcasted</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">SubTypeofAbstractFactory.(exprs::Vector{FExpr};unescaped::NTuple{N,Symbol}=()) where N
SubTypeofAbstractFactory.(exprs::NTuple{N,FExpr};unescaped::NTuple{M,Symbol}=()) where {N,M}</code></pre><p>Broadcast construction of concrete subtypes of <code>AbstractFactory</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L111-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{Tuple},Hamiltonian.Utilities.Factory.Field}" href="#Base.convert-Tuple{Type{Tuple},Hamiltonian.Utilities.Factory.Field}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">convert(::Type{Tuple},f::Field)
convert(::Type{Tuple{Symbol,FExpr}},f::Field)</code></pre><p>Convert a <code>Field</code> to tuple.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L285-L290">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Tuple{Hamiltonian.Utilities.Factory.Block}" href="#Base.push!-Tuple{Hamiltonian.Utilities.Factory.Block}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">push!(b::Block,parts::FExpr...)
push!(b::Block,parts::Block...)</code></pre><p>Push other parts into the body of a block.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L318-L323">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.replace-Tuple{Hamiltonian.Utilities.Factory.AbstractFactory}" href="#Base.replace-Tuple{Hamiltonian.Utilities.Factory.AbstractFactory}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">replace(f::AbstractFactory;kwargs...)</code></pre><p>Return a copy of a concrete <code>AbstractFactory</code> with some of the field values replaced by the keyword arguments.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L104-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Tuple{IO,Hamiltonian.Utilities.Factory.AbstractFactory}" href="#Base.show-Tuple{IO,Hamiltonian.Utilities.Factory.AbstractFactory}"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">show(io::IO,f::AbstractFactory)</code></pre><p>Show a concrete <code>AbstractFactory</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/c333d685a7e0baed6ccc9fa74a6f69dffa21fc19/src/Utilities/Factory.jl#L73-L77">source</a></section><footer><hr/><a class="previous" href="Introduction.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="Tree.html"><span class="direction">Next</span><span class="title">Tree</span></a></footer></article></body></html>
