<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Factory · Hamiltonian.jl</title><link rel="canonical" href="https://quantum-many-body.github.io/Hamiltonian.jl/latest/man/Utilities/Factory.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Hamiltonian.jl logo"/></a><h1>Hamiltonian.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">Home</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../../tutorial/UnitcellDescription.html">Unitcell Description</a></li><li><a class="toctext" href="../../tutorial/EngineAppInterface.html">Engine App Interface</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><span class="toctext">Utilities</span><ul><li><a class="toctext" href="Introduction.html">Introduction</a></li><li class="current"><a class="toctext" href="Factory.html">Factory</a><ul class="internal"><li><a class="toctext" href="#Inference-1">Inference</a></li><li><a class="toctext" href="#Argument-1">Argument</a></li><li><a class="toctext" href="#Parameter-1">Parameter</a></li><li><a class="toctext" href="#Field-1">Field</a></li><li><a class="toctext" href="#Block-1">Block</a></li><li><a class="toctext" href="#FunctionFactory-1">FunctionFactory</a></li><li><a class="toctext" href="#TypeFactory-1">TypeFactory</a></li><li><a class="toctext" href="#Manual-1">Manual</a></li></ul></li><li><a class="toctext" href="Tree.html">Tree</a></li><li><a class="toctext" href="NamedVector.html">Named vector</a></li><li><a class="toctext" href="GoodQuantumNumber.html">Good quantum numbers</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li>Utilities</li><li><a href="Factory.html">Factory</a></li></ul><a class="edit-page" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/master/docs/src/man/Utilities/Factory.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Factory</span><a class="fa fa-bars" href="#"></a></div></header><div></div><h1><a class="nav-anchor" id="Factory-1" href="#Factory-1">Factory</a></h1><p>The aim of <code>Factory</code> is to provide tools to hack into Julia codes without knowing the details of their abstract syntax trees and regularize the mechanism to &quot;escape&quot; variables in <code>Expr</code> expressions, so that users can manipulate the existing codes, modify them and generate new ones in macros. In particular, <code>Factory</code> in this module means the representation of certain blocks of Julia codes by a usual Julia struct. This representation is much easier to comprehend than the canonical <code>Expr</code> representation and makes it far more convenient to define macros. In general, we propose the following requirements that any factory must satisfy:</p><ul><li><em>DECOMPOSITION</em> - An <code>Expr</code> expression can be decomposed into its corresponding factory by the factory&#39;s constructor.</li><li><em>COMPOSITION</em> - A factory can compose its corresponding <code>Expr</code> expression by calling itself.</li><li><em>ESCAPE</em> - A variable should be escaped or not in the composed <code>Expr</code> expression by a factory depends on keyword arguments <code>escaped</code> or <code>unescaped</code> passed to the factory call, which are tuple of <code>Symbols</code>. Specifically, when <code>escaped</code> is provided, a variable should be escaped if its name is in <code>escaped</code>, whereas, when <code>unescaped</code> is provided, a variable should be escaped if its name is not in <code>unescaped</code>. A factory can choose which keyword arguments should be used for convenience, or can choose both with different keyword arguments for different parts of it.</li></ul><p>The first two requirements define the basic interfaces to interact with factories, and the third requirement proposes the escape mechanism of variables.</p><p>Out of practical purposes, we implemente 7 kinds of factories, i.e. <em><a href="Factory.html#Hamiltonian.Utilities.Factory.Inference"><code>Inference</code></a></em>, <em><a href="Factory.html#Hamiltonian.Utilities.Factory.Argument"><code>Argument</code></a></em>, <em><a href="Factory.html#Hamiltonian.Utilities.Factory.Parameter"><code>Parameter</code></a></em>, <em><a href="Factory.html#Hamiltonian.Utilities.Factory.Field"><code>Field</code></a></em>, <em><a href="Factory.html#Hamiltonian.Utilities.Factory.Block"><code>Block</code></a></em>, <em><a href="Factory.html#Hamiltonian.Utilities.Factory.FunctionFactory"><code>FunctionFactory</code></a></em> and <em><a href="Factory.html#Hamiltonian.Utilities.Factory.TypeFactory"><code>TypeFactory</code></a></em>, which represent <em>a type inference</em>, <em>a function argument</em>, <em>a method or type parameter</em>, <em>a struct field</em>, <em>a <code>begin ... end</code> block</em>, <em>a function itself</em> and <em>a struct itself</em>, respectively. Some of the basic methods making the above requirements fulfilled with these types are based on the powerful functions defined in <a href="https://github.com/MikeInnes/MacroTools.jl"><code>MacroTools</code></a>.</p><h2><a class="nav-anchor" id="Inference-1" href="#Inference-1">Inference</a></h2><p>An <a href="Factory.html#Hamiltonian.Utilities.Factory.Inference"><code>Inference</code></a> has 3 attributes:</p><ul><li><code>head::Union{Symbol,Nothing}</code>: the head of the type inference, which must be one of <code>(nothing,:(::),:(&lt;:),:curly)</code></li><li><code>name::Union{Symbol,Nothing}</code>: the name of the type inference</li><li><code>params::Union{Inference,Vector{Inference},Nothing}</code>: the parameters of the type inference</li></ul><p>All valid expressions representing type inferences can be passed to the constructor:</p><pre><code class="language-julia-repl">julia&gt; Inference(:T)
Inference(
  head:   nothing
  name:   T
  params: nothing
)

julia&gt; Inference(:(::T))
Inference(
  head:   ::
  name:   nothing
  params: T
)

julia&gt; Inference(:(&lt;:Number))
Inference(
  head:   &lt;:
  name:   nothing
  params: Number
)

julia&gt; Inference(:(Vector{T}))
Inference(
  head:   curly
  name:   Vector
  params: Inference[T]
)

julia&gt; Inference(:(Vector{Tuple{String,Int}}))
Inference(
  head:   curly
  name:   Vector
  params: Inference[Tuple{String, Int}]
)

julia&gt; Inference(:(Type{&lt;:Number}))
Inference(
  head:   curly
  name:   Type
  params: Inference[&lt;:Number]
)</code></pre><p>On the other hand, you can use the macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@inference-Tuple{Union{Expr, Symbol}}"><code>@inference</code></a> to construct an <code>Inference</code> directly from a type inference:</p><pre><code class="language-julia-repl">julia&gt; @inference Vector{Tuple{String,Int}}
Inference(
  head:   curly
  name:   Vector
  params: Inference[Tuple{String, Int}]
)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ol><li><code>Inference</code> is a recursive struct, i.e. it recursively decomposes a type inference until the final type inference is just a <code>Symbol</code>.</li><li>When the input expression is a <code>Symbol</code>, the <code>head</code> and <code>params</code> attributes of the resulting <code>Inference</code> is <code>nothing</code>. Otherwise, its <code>head</code> is the same with that of the input expression, and the <code>args</code> of the input expression will be further decomposed, whose result will be stored in <code>params</code>.</li><li>When the head of the input expression is <code>:(::)</code> or <code>:(&lt;:)</code>, the <code>params</code> is an <code>Inference</code> whereas when the head of the input expression is <code>:curly</code>, the <code>params</code> is a <code>Vector{Inference}</code>.</li></ol></div></div><p><a href="Factory.html#Hamiltonian.Utilities.Factory.Inference"><code>Inference</code></a> uses the keyword argument <code>unescaped</code> to escape variables, e.g.</p><pre><code class="language-julia-repl">julia&gt; Inference(:(Vector{T}))() |&gt; println
($(Expr(:escape, :Vector))){$(Expr(:escape, :T))}

julia&gt; Inference(:(Vector{T}))(unescaped=(:T,)) |&gt; println
($(Expr(:escape, :Vector))){T}

julia&gt; Inference(:(Vector{T}))(unescaped=(:Vector,:T)) |&gt; println
Vector{T}</code></pre><h2><a class="nav-anchor" id="Argument-1" href="#Argument-1">Argument</a></h2><p>An <a href="Factory.html#Hamiltonian.Utilities.Factory.Argument"><code>Argument</code></a> has 4 attributes:</p><ul><li><code>name::Union{Symbol,Nothing}</code>: the name of the argument</li><li><code>type::Inference</code>: the type inference of the argument</li><li><code>slurp::Bool</code>: whether the argument should be expanded by <code>...</code></li><li><code>default::Any</code>: the default value of the argument, <code>nothing</code> for those with no default values</li></ul><p>All valid expressions representing the arguments of functions can be passed to the constructor:</p><pre><code class="language-julia-repl">julia&gt; Argument(:arg)
Argument(
  name:    arg
  type:    Any
  slurp:   false
  default: nothing
)

julia&gt; Argument(:(arg::ArgType))
Argument(
  name:    arg
  type:    ArgType
  slurp:   false
  default: nothing
)

julia&gt; Argument(:(arg::ArgType...))
Argument(
  name:    arg
  type:    ArgType
  slurp:   true
  default: nothing
)

julia&gt; Argument(:(arg::ArgType=default))
Argument(
  name:    arg
  type:    ArgType
  slurp:   false
  default: default
)</code></pre><p>Or you can use the macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@argument-Tuple{Union{Expr, Symbol}}"><code>@argument</code></a> for a direct construction from an argument declaration:</p><pre><code class="language-julia-repl">julia&gt; @argument arg::ArgType=default
Argument(
  name:    arg
  type:    ArgType
  slurp:   false
  default: default
)</code></pre><p>The construction from such expressions is based on the the <code>MacroTools.splitarg</code> function.</p><p><a href="Factory.html#Hamiltonian.Utilities.Factory.Argument"><code>Argument</code></a> also uses the keyword argument <code>unescaped</code> to escape variables, e.g.</p><pre><code class="language-julia-repl">julia&gt; Argument(:(arg::ArgType=default))(unescaped=(:ArgType,:default)) |&gt; println
arg::ArgType=default</code></pre><p>It can be seen the name of an argument will never be escaped even though it is not in the <code>unescaped</code> tuple. This is obvious since the name of a function argument is always local. By the way, the composition of an <a href="Factory.html#Hamiltonian.Utilities.Factory.Argument"><code>Argument</code></a> expression is based on the <code>MacroTools.combinearg</code> function.</p><h2><a class="nav-anchor" id="Parameter-1" href="#Parameter-1">Parameter</a></h2><p>A <a href="Factory.html#Hamiltonian.Utilities.Factory.Parameter"><code>Parameter</code></a> has 2 attributes:</p><ul><li><code>name::Union{Symbol,Nothing}</code>: the name of the parameter</li><li><code>type::Union{Inference,Nothing}</code>: the type inference of the parameter</li></ul><p>All expressions that represent type parameters or method parameters are allowed to be passed to the constructor:</p><pre><code class="language-julia-repl">julia&gt; Parameter(:T)
Parameter(
  name: T
  type: nothing
)

julia&gt; Parameter(:(&lt;:Number))
Parameter(
  name: nothing
  type: Number
)

julia&gt; Parameter(:(T&lt;:Number))
Parameter(
  name: T
  type: Number
)

julia&gt; Parameter(:(::Int))
Parameter(
  name: nothing
  type: Int
)</code></pre><p>The macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@parameter-Tuple{Union{Expr, Symbol}}"><code>@parameter</code></a> completes the construction directly from a parameter declaration:</p><pre><code class="language-julia-repl">julia&gt; @parameter T&lt;:Number
Parameter(
  name: T
  type: Number
)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ol><li>We use <code>nothing</code> to denote a missing <code>name</code> or <code>type.</code></li><li>Two subtle situations of type/method parameters, e.g. <code>MyType{T}</code> and <code>MyType{Int}</code>, are distinguished by <code>Parameter(:T)</code> and <code>Parameter(:(::Int))</code>. The <code>name</code> and <code>type</code> attributes of the resulting <code>Parameter</code>s are, for the first case, <code>:T</code> and <code>nothing</code>, while for the second case, <code>nothing</code> and <code>:T</code>, respectively. Moreover, the callings of the factories for these two cases are also different, e.g. <code>Parameter(:T)()==:T</code> and <code>Parameter(:(::Int))==:(&lt;:$(esc(Int)))</code>.</li></ol></div></div><p><a href="Factory.html#Hamiltonian.Utilities.Factory.Parameter"><code>Parameter</code></a> uses the keyword argument <code>unescaped</code> to escape variables, too, e.g.</p><pre><code class="language-julia-repl">julia&gt; Parameter(:(N&lt;:Vector{T}))(unescaped=(:T,)) |&gt; println
N &lt;: ($(Expr(:escape, :Vector))){T}</code></pre><p>As is similar to <a href="Factory.html#Hamiltonian.Utilities.Factory.Argument"><code>Argument</code></a>, the <code>name</code> of a method/type parameter will never be escaped because of its local scope.</p><h2><a class="nav-anchor" id="Field-1" href="#Field-1">Field</a></h2><p>A <a href="Factory.html#Hamiltonian.Utilities.Factory.Field"><code>Field</code></a> has 2 attributes:</p><ul><li><code>name::Symbol</code>: the name of the field</li><li><code>type::Inference</code>: the type inference of the field</li></ul><p>Legal expressions can be used to construct a <code>Field</code> instance by its constructor:</p><pre><code class="language-julia-repl">julia&gt; Field(:field)
Field(
  name: field
  type: Any
)

julia&gt; Field(:(field::FieldType))
Field(
  name: field
  type: FieldType
)

julia&gt; Field(:(field::ParametricType{T}))
Field(
  name: field
  type: ParametricType{T}
)</code></pre><p>The macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@field-Tuple{Union{Expr, Symbol}}"><code>@field</code></a> is also provided to help the construction directly from a field declaration:</p><pre><code class="language-julia-repl">julia&gt; @field field::FieldType
Field(
  name: field
  type: FieldType
)</code></pre><p>The construction from these expressions is based on the <code>MacroTools.splitarg</code> function.</p><p><a href="Factory.html#Hamiltonian.Utilities.Factory.Field"><code>Field</code></a> uses the keyword argument <code>unescaped</code> to escape variables as well, e.g.</p><pre><code class="language-julia-repl">julia&gt; Field(:(field::Dict{N,D}))(unescaped=(:N,:D)) |&gt; println
field::($(Expr(:escape, :Dict))){N, D}</code></pre><p>The name of a struct will never be escaped either because it is a local variable tightly binding to a struct. It is noted that the composition of field expressions is based on the <code>MacroTools.combinefield</code> function.</p><h2><a class="nav-anchor" id="Block-1" href="#Block-1">Block</a></h2><p>A <a href="Factory.html#Hamiltonian.Utilities.Factory.Block"><code>Block</code></a> has only one attribute:</p><ul><li><code>body::Vector{Any}</code>: the body of the <code>begin ... end</code> block</li></ul><p>Any expression can be passed to the constructor of <code>Block</code>:</p><pre><code class="language-julia-repl">julia&gt; Block(:(x=1))
Block(
  body: Any[:(x = 1)]
)

julia&gt; Block(:(x=1;y=2))
Block(
  body: Any[:(x = 1), :(#= none:1 =#), :(y = 2)]
)

julia&gt; Block(:(begin x=1 end))
Block(
  body: Any[:(#= none:1 =#), :(x = 1)]
)

julia&gt; Block(quote
               x=1
               y=2
           end)
Block(
  body: Any[:(#= none:2 =#), :(x = 1), :(#= none:3 =#), :(y = 2)]
)</code></pre><p>Or you can construct a <code>Block</code> instance directly from any code by the macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@block-Tuple{Vararg{Union{Expr, Symbol},N} where N}"><code>@block</code></a>:</p><pre><code class="language-julia-repl">julia&gt; @block x=1 y=2
Block(
  body: Any[:(x = 1), :(y = 2)]
)</code></pre><p>The body of a <code>block</code> can also be extended by the <a href="Factory.html#Base.push!-Tuple{Hamiltonian.Utilities.Factory.Block}"><code>push!</code></a> function or the <a href="Factory.html#Hamiltonian.Utilities.Factory.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@push!</code></a> macro.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ol><li>The body of a <code>Block</code> is somewhat &quot;flattened&quot;, i.e. it contains no <code>begin ... end</code> blocks. During the initialization, any such input block will be unblocked and added to the body part by part. So is the <a href="Factory.html#Base.push!-Tuple{Hamiltonian.Utilities.Factory.Block}"><code>push!</code></a> and <a href="Factory.html#Hamiltonian.Utilities.Factory.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@push!</code></a> procedures.</li><li>All <code>LineNumberNode</code>s generated by the input codes will also be included in the block&#39;s body. However, you can use <a href="Factory.html#Hamiltonian.Utilities.Factory.rmlines!-Tuple{Hamiltonian.Utilities.Factory.Block}"><code>rmlines!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@rmlines!-Tuple{Expr}"><code>@rmlines!</code></a> to remove them from the body of an existing <code>Block</code>, or use <a href="Factory.html#MacroTools.rmlines-Tuple{Hamiltonian.Utilities.Factory.Block}"><code>rmlines</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@rmlines-Tuple{Expr}"><code>@rmlines</code></a> to get a copy with them removed in the body.</li></ol></div></div><p>Different from previous factories, <a href="Factory.html#Hamiltonian.Utilities.Factory.Block"><code>Block</code></a> uses the keyword argument <code>escaped</code> to escape variables. This is because variables in a block are often local ones and should not be escaped. Therefore, only those defined in other modules should be noted and escaped, which usually constitute the minority. For example,</p><pre><code class="language-julia-repl">julia&gt; Block(:(x=1;y=2;z=Int[1,2,3]))(escaped=(:Int,)) |&gt; println
begin
    x = 1
    #= none:1 =#
    y = 2
    #= none:1 =#
    z = ($(Expr(:escape, :Int)))[1, 2, 3]
end</code></pre><h2><a class="nav-anchor" id="FunctionFactory-1" href="#FunctionFactory-1">FunctionFactory</a></h2><p>A <a href="Factory.html#Hamiltonian.Utilities.Factory.FunctionFactory"><code>FunctionFactory</code></a> has 7 attributes:</p><ul><li><code>name::Union{Symbol,Expr}</code>: the name of the function</li><li><code>params::Vector{Inference}</code>: the method parameters of the function</li><li><code>args::Vector{Argument}</code>: the positional arguments of the function</li><li><code>kwargs::Vector{Argument}</code>: the keyword arguments of the function</li><li><code>rtype::Inference</code>: the return type of the function</li><li><code>whereparams::Vector{Parameter}</code>: the method parameters specified by the <code>where</code> keyword</li><li><code>body::Block</code>: the body of the function</li></ul><p>All expressions that represent functions are allowed to be passed to the constructor:</p><pre><code class="language-julia-repl">julia&gt; FunctionFactory(:(f()=nothing))
FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[]
  kwargs:      Argument[]
  rtype:       Any
  whereparams: Parameter[]
  body:        begin
                   nothing
               end
)

julia&gt; FunctionFactory(:(f(x)=x))
FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[x::Any]
  kwargs:      Argument[]
  rtype:       Any
  whereparams: Parameter[]
  body:        begin
                   x
               end
)

julia&gt; FunctionFactory(:(f(x::Int,y::Int;choice::Function=sum)=choice(x,y)))
FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[x::Int, y::Int]
  kwargs:      Argument[choice::Function=sum]
  rtype:       Any
  whereparams: Parameter[]
  body:        begin
                   choice(x, y)
               end
)

julia&gt; FunctionFactory(:(f(x::T,y::T;choice::Function=sum) where T&lt;:Number=choice(x,y)))
FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[x::T, y::T]
  kwargs:      Argument[choice::Function=sum]
  rtype:       Any
  whereparams: Parameter[T &lt;: Number]
  body:        begin
                   choice(x, y)
               end
)

julia&gt; FunctionFactory(:((f(x::T,y::T;choice::Function=sum)::T) where T&lt;:Number=choice(x,y)))
FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[x::T, y::T]
  kwargs:      Argument[choice::Function=sum]
  rtype:       T
  whereparams: Parameter[T &lt;: Number]
  body:        begin
                   choice(x, y)
               end
)

julia&gt; FunctionFactory(:(
           function (f(x::T,y::T;choice::Function=sum)::T) where T&lt;:Number
               choice(x,y)
           end
       ))
FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[x::T, y::T]
  kwargs:      Argument[choice::Function=sum]
  rtype:       T
  whereparams: Parameter[T &lt;: Number]
  body:        begin
                   #= none:3 =#
                   choice(x, y)
               end
)

julia&gt; FunctionFactory(
           quote
               function (f(x::T,y::T;choice::Function=sum)::T) where T&lt;:Number
                   choice(x,y)
               end
           end
       )
FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[x::T, y::T]
  kwargs:      Argument[choice::Function=sum]
  rtype:       T
  whereparams: Parameter[T &lt;: Number]
  body:        begin
                   #= none:4 =#
                   choice(x, y)
               end
)</code></pre><p>Similarly, an instance can also be constructed from the macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@functionfactory-Tuple{Expr}"><code>@functionfactory</code></a>:</p><pre><code class="language-julia-repl">julia&gt; @functionfactory (f(x::T,y::T;choice::Function=sum)::T) where T&lt;:Number=choice(x,y)
FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[x::T, y::T]
  kwargs:      Argument[choice::Function=sum]
  rtype:       T
  whereparams: Parameter[T &lt;: Number]
  body:        begin
                   choice(x, y)
               end
)</code></pre><p>The construction from such expressions are based on the <code>MacroTools.splitdef</code> function.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ol><li>Since Julia 0.7, the form <code>MyType{D}(data::D) where D</code> only appears in struct constructors, therefore, the attribute <code>:params</code> of a function factory is nonempty only when this factory aims to represent a struct constructor.</li><li>Usually, the name of a function factory is a <code>Symbol</code>. However, if the factory aims to extend some methods of a function defined in another module, e.g., <code>Base.eltype</code>, the name will be an <code>Expr</code>.</li></ol></div></div><p>Since <a href="Factory.html#Hamiltonian.Utilities.Factory.FunctionFactory"><code>FunctionFactory</code></a> involves not only factories using <code>unescaped</code> but also factories using <code>escaped</code>, it adopts both to escape variables, with <code>unescaped</code> for <code>params</code>, <code>args</code>, <code>kwargs</code>, <code>rtype</code> and <code>whereparams</code> while <code>escaped</code> for <code>name</code> and <code>body</code>. It is worth to emphasize that the name of a function factory is affected by the <code>escaped</code> argument. Specifically, when the name is a <code>Symbol</code> and is in the <code>escaped</code> tuple, it will be escaped. Otherwise it will not, especially when it is an <code>Expr</code>, it will never be escaped because an <code>Expr</code> cannot be a element of a <code>NTuple{N,Symbol} where N</code>. See examples,</p><pre><code class="language-julia-repl">julia&gt; FunctionFactory(:((f(x::T,y::T;choice::Function=sum)::T) where T&lt;:Number=max(x,y,choice(x,y))))(unescaped=(:T,),escaped=(:f,:max,)) |&gt; println
function (($(Expr(:escape, :f)))(x::T, y::T; choice::$(Expr(:escape, :Function))=$(Expr(:escape, :sum)))::T) where T &lt;: $(Expr(:escape, :Number))
    #= /home/travis/.julia/packages/MacroTools/4AjBS/src/utils.jl:302 =#
    begin
        ($(Expr(:escape, :max)))(x, y, choice(x, y))
    end
end

julia&gt; FunctionFactory(:((f(x::T,y::T;choice::Function=sum)::T) where T&lt;:Number=max(x,y,choice(x,y))))(unescaped=(:T,),escaped=(:max,)) |&gt; println
function (f(x::T, y::T; choice::$(Expr(:escape, :Function))=$(Expr(:escape, :sum)))::T) where T &lt;: $(Expr(:escape, :Number))
    #= /home/travis/.julia/packages/MacroTools/4AjBS/src/utils.jl:302 =#
    begin
        ($(Expr(:escape, :max)))(x, y, choice(x, y))
    end
end</code></pre><p>The compositions of function expressions are based on the <code>MacroTools.combinedef</code> function.</p><p>Other features include:</p><ul><li>Positional arguments can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}"><code>addargs!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addargs!</code></a></li><li>Keyword arguments can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addkwargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}"><code>addkwargs!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addkwargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addkwargs!</code></a></li><li>Where parameters can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addwhereparams!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}"><code>addwhereparams!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addwhereparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addwhereparams!</code></a></li><li>Body can be extended by <a href="Factory.html#Hamiltonian.Utilities.Factory.extendbody!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}"><code>extendbody!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@extendbody!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@extendbody!</code></a></li></ul><h2><a class="nav-anchor" id="TypeFactory-1" href="#TypeFactory-1">TypeFactory</a></h2><p>A <a href="Factory.html#Hamiltonian.Utilities.Factory.TypeFactory"><code>TypeFactory</code></a> has 6 attributes:</p><ul><li><code>name::Symbol</code>: the name of the struct</li><li><code>mutable::Bool</code>: whether or not the struct is mutable</li><li><code>params::Vector{Parameter}</code>: the type parameters of the struct</li><li><code>supertype::Inference</code>: the supertype of the struct</li><li><code>fields::Vector{Field}</code>: the fields of the struct</li><li><code>constructors::Vector{FunctionFactory}</code>: the inner constructors of the struct</li></ul><p>Any expression representing valid struct definitions can be passed to the constructor:</p><pre><code class="language-julia-repl">julia&gt; TypeFactory(:(struct StructName end))
TypeFactory(
  name:         StructName
  mutable:      false
  params:       Parameter[]
  supertype:    Any
  fields:       Field[]
  constructors: FunctionFactory[]
)

julia&gt; TypeFactory(:(struct StructName{T} end))
TypeFactory(
  name:         StructName
  mutable:      false
  params:       Parameter[T]
  supertype:    Any
  fields:       Field[]
  constructors: FunctionFactory[]
)

julia&gt; TypeFactory(:(struct Child{T} &lt;: Parent{T} end))
TypeFactory(
  name:         Child
  mutable:      false
  params:       Parameter[T]
  supertype:    Parent{T}
  fields:       Field[]
  constructors: FunctionFactory[]
)

julia&gt; TypeFactory(:(
           struct Child{T&lt;:Number} &lt;: Parent{T}
               field1::T
               field2::T
           end
       ))
TypeFactory(
  name:         Child
  mutable:      false
  params:       Parameter[T &lt;: Number]
  supertype:    Parent{T}
  fields:       Field[field1::T, field2::T]
  constructors: FunctionFactory[]
)

julia&gt; TypeFactory(
           quote
               struct Child{T&lt;:Number} &lt;: Parent{T}
                   field1::T
                   field2::T
               end
           end
       )
TypeFactory(
  name:         Child
  mutable:      false
  params:       Parameter[T &lt;: Number]
  supertype:    Parent{T}
  fields:       Field[field1::T, field2::T]
  constructors: FunctionFactory[]
)</code></pre><p>Also, the macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@typefactory-Tuple{Expr}"><code>@typefactory</code></a> supports the construction directly from a type definition:</p><pre><code class="language-julia-repl">julia&gt; @typefactory struct Child{T&lt;:Number} &lt;: Parent{T}
                       field1::T
                       field2::T
                       Child(field1::T,field2::T=zero(T)) where T=new{T}(field1,field2)
                   end
TypeFactory(
  name:         Child
  mutable:      false
  params:       Parameter[T &lt;: Number]
  supertype:    Parent{T}
  fields:       Field[field1::T, field2::T]
  constructors: FunctionFactory[
                  function (Child(field1::T, field2::T=zero(T); )::Any) where T
                      #= /home/travis/.julia/packages/MacroTools/4AjBS/src/utils.jl:302 =#
                      begin
                          new{T}(field1, field2)
                      end
                  end
                  ]
)</code></pre><p>The construction from these expressions is based on the <code>MacroTools.splitstructdef</code> function.</p><p><a href="Factory.html#Hamiltonian.Utilities.Factory.TypeFactory"><code>TypeFactory</code></a> also uses both keyword arguments, i.e. <code>unescaped</code> and <code>escaped</code>, to escape variables, with the former for <code>params</code>, <code>supertype</code> and <code>fields</code>, the latter for <code>name</code>, and both for <code>constructors</code>. For example,</p><pre><code class="language-julia-repl">julia&gt; (@typefactory struct Child{T&lt;:Number} &lt;: Parent{T} field::T; Child(field::T) where T=new{T}(field) end)(unescaped=(:T,),escaped=(:Child,)) |&gt;println
struct ($(Expr(:escape, :Child))){T &lt;: $(Expr(:escape, :Number))} &lt;: ($(Expr(:escape, :Parent))){T}
    #= /home/travis/.julia/packages/MacroTools/4AjBS/src/structdef.jl:57 =#
    field::T
    #= /home/travis/.julia/packages/MacroTools/4AjBS/src/structdef.jl:58 =#
    function (($(Expr(:escape, :Child)))(field::T; )::$(Expr(:escape, :Any))) where T
        #= /home/travis/.julia/packages/MacroTools/4AjBS/src/utils.jl:302 =#
        begin
            new{T}(field)
        end
    end
end</code></pre><p>The composition of a type expression is based on the <code>MacroTools.combinestructdef</code> function.</p><p>Other features include:</p><ul><li>Fields can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addfields!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory}"><code>addfields!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addfields!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addfields!</code></a></li><li>Type parameters can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addparams!-Tuple{Union{FunctionFactory, TypeFactory}}"><code>addparams!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addparams!</code></a></li><li>Inner constructors can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addconstructors!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory}"><code>addconstructors!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addconstructors!-Tuple{Any,Vararg{Expr,N} where N}"><code>@addconstructors!</code></a></li></ul><h2><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.FExpr" href="#Hamiltonian.Utilities.Factory.FExpr"><code>Hamiltonian.Utilities.Factory.FExpr</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Factory expression types, which is defined as <code>Union{Symbol,Expr}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.RawExpr" href="#Hamiltonian.Utilities.Factory.RawExpr"><code>Hamiltonian.Utilities.Factory.RawExpr</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Whether or not to show raw expressions of factoies.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Argument" href="#Hamiltonian.Utilities.Factory.Argument"><code>Hamiltonian.Utilities.Factory.Argument</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Argument(name::Union{Symbol,Nothing},type::Inference,slurp::Bool,default::Any)
Argument(;name::Union{Symbol,Nothing}=nothing,type::Inference=Inference(:Any),slurp::Bool=false,default::Any=nothing)
Argument(expr::FExpr)</code></pre><p>The struct to describe a argument of a <code>function</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L183-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Argument-Tuple{Val{true}}" href="#Hamiltonian.Utilities.Factory.Argument-Tuple{Val{true}}"><code>Hamiltonian.Utilities.Factory.Argument</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(a::Argument)(::typeof(RawExpr))
(a::Argument)(;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>Convert an <code>Argument</code> to the <code>Expr</code> representation of the argument it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L206-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Block" href="#Hamiltonian.Utilities.Factory.Block"><code>Hamiltonian.Utilities.Factory.Block</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Block(parts::FExpr...)</code></pre><p>The struct to describe a <code>begin ... end</code> block.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L296-L300">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Block-Tuple{Val{true}}" href="#Hamiltonian.Utilities.Factory.Block-Tuple{Val{true}}"><code>Hamiltonian.Utilities.Factory.Block</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(b::Block)(::typeof(RawExpr))
(b::Block)(;escaped::NTuple{N,Symbol}=()) where N</code></pre><p>Convert a <code>Block</code> to the <code>Expr</code> representation of the <code>begin ... end</code> block it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L313-L318">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Field" href="#Hamiltonian.Utilities.Factory.Field"><code>Hamiltonian.Utilities.Factory.Field</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Field(name::Symbol,type::Inference)
Field(;name::Symbol,type::FExpr=Inference(:Any))
Field(expr::Expr)</code></pre><p>The struct to describe a field of a <code>struct</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L266-L272">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Field-Tuple{Val{true}}" href="#Hamiltonian.Utilities.Factory.Field-Tuple{Val{true}}"><code>Hamiltonian.Utilities.Factory.Field</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(f::Field)(::typeof(RawExpr))
(f::Field)(;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>Convert a <code>Field</code> to the <code>Expr</code> representation of the field it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L287-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.FunctionFactory" href="#Hamiltonian.Utilities.Factory.FunctionFactory"><code>Hamiltonian.Utilities.Factory.FunctionFactory</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FunctionFactory(name::FExpr,params::Vector{Inference},args::Vector{Argument},kwargs::Vector{Argument},rtype::Inference,whereparams::Vector{Parameter},body::Block)
FunctionFactory(    ;name::FExpr,
                    params::Vector{Inference}=Inference[],
                    args::Vector{Argument}=Argument[],
                    kwargs::Vector{Argument}=Argument[],
                    rtype::Inference=Inference(:Any),
                    whereparams::Vector{Parameter}=Parameter[],
                    body::Block=Block()
                    )
FunctionFactory(expr::Expr)</code></pre><p>The struct to describe a <code>function</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L371-L384">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.FunctionFactory-Tuple{Val{true}}" href="#Hamiltonian.Utilities.Factory.FunctionFactory-Tuple{Val{true}}"><code>Hamiltonian.Utilities.Factory.FunctionFactory</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(ff::FunctionFactory)(::typeof(RawExpr))
(ff::FunctionFactory)(;unescaped::NTuple{N,Symbol}=(),escaped::NTuple{M,Symbol}=()) where {N,M}</code></pre><p>Convert a <code>FunctionFactory</code> to the <code>Expr</code> representation of the <code>function</code> it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L423-L428">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Inference" href="#Hamiltonian.Utilities.Factory.Inference"><code>Hamiltonian.Utilities.Factory.Inference</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Inference(head::Union{Symbol,Nothing},name::Union{Symbol,Nothing},params::Union{Inference,Vector{Inference},Nothing})
Inference(;
        head::Union{Symbol,Nothing}=nothing,
        name::Union{Symbol,Nothing}=nothing,
        params::Union{Inference,Vector{Inference},Nothing}=nothing,
        )
Inference(expr::FExpr)</code></pre><p>The struct to describe a type inference.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L113-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Inference-Tuple{Val{true}}" href="#Hamiltonian.Utilities.Factory.Inference-Tuple{Val{true}}"><code>Hamiltonian.Utilities.Factory.Inference</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(i::Inference)(::typeof(RawExpr))
(i::Inference)(;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>Convert a <code>Inference</code> to the <code>Expr</code> representation of the type inference it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L158-L163">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Parameter" href="#Hamiltonian.Utilities.Factory.Parameter"><code>Hamiltonian.Utilities.Factory.Parameter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Parameter(name::Union{Symbol,Nothing},type::Union{Inference,Nothing})
Parameter(;name::Union{Symbol,Nothing}=nothing,type::Union{Inference,Nothing}=nothing)
Parameter(expr::FExpr)</code></pre><p>The struct to describe a parameter of a <code>function</code> or a <code>type</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L215-L221">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Parameter-Tuple{Val{true}}" href="#Hamiltonian.Utilities.Factory.Parameter-Tuple{Val{true}}"><code>Hamiltonian.Utilities.Factory.Parameter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(p::Parameter)(::typeof(RawExpr))
(p::Parameter)(;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>Convert a <code>Parameter</code> to the <code>Expr</code> representation of the parameter it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L249-L254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.TypeFactory" href="#Hamiltonian.Utilities.Factory.TypeFactory"><code>Hamiltonian.Utilities.Factory.TypeFactory</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TypeFactory(name::Symbol,mutable::Bool,params::Vector{Parameter},supertype::Inference,fields::Vector{Field},constructors::Vector{FunctionFactory})
TypeFactory(    ;name::Symbol,
                mutable::Bool=false,
                params::Vector{Parameter}=Parameter[],
                supertype::Inference=Inference(:Any),
                fields::Vector{Field}=Field[],
                constructors::Vector{FunctionFactory}=FunctionFactory[],
                )
TypeFactory(expr::Expr)</code></pre><p>The struct to describe a <code>struct</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L520-L532">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.TypeFactory-Tuple{Val{true}}" href="#Hamiltonian.Utilities.Factory.TypeFactory-Tuple{Val{true}}"><code>Hamiltonian.Utilities.Factory.TypeFactory</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(tf::TypeFactory)(::typeof(RawExpr))
(tf::TypeFactory)(;unescaped::NTuple{N,Symbol}=()) where N</code></pre><p>Convert a <code>TypeFactory</code> to the <code>Expr</code> representation of the <code>struct</code> it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L568-L573">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@addargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@addargs!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addargs! ff args::FExpr...</code></pre><p>Add a couple of positional arguments to a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L462-L466">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addconstructors!-Tuple{Any,Vararg{Expr,N} where N}" href="#Hamiltonian.Utilities.Factory.@addconstructors!-Tuple{Any,Vararg{Expr,N} where N}"><code>Hamiltonian.Utilities.Factory.@addconstructors!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addconstructors! tf constructors::Expr...</code></pre><p>Add a couple of constructors to a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L622-L626">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addfields!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@addfields!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@addfields!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addfields! tf fields::FExpr...</code></pre><p>Add a couple of fields to a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L605-L609">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addkwargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@addkwargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@addkwargs!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addkwargs! ff kwargs::FExpr...</code></pre><p>Add a couple of keyword arguments to a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L479-L483">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@addparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@addparams!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addparams! f params::FExpr...</code></pre><p>Add a couple of method parameters to a function factory or a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L642-L646">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addwhereparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@addwhereparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@addwhereparams!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addwhereparams! f whereparams::FExpr...</code></pre><p>Add a couple of method parameters to a function factory or a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L506-L510">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@argument-Tuple{Union{Expr, Symbol}}" href="#Hamiltonian.Utilities.Factory.@argument-Tuple{Union{Expr, Symbol}}"><code>Hamiltonian.Utilities.Factory.@argument</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@argument expr::FExpr</code></pre><p>Construct an <code>Argument</code> directly from an argument statement.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L199-L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@block-Tuple{Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@block-Tuple{Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@block</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@block parts::FExpr...</code></pre><p>Construct a <code>Block</code> directly from a <code>begin ... end</code> block definition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L306-L310">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@extendbody!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@extendbody!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@extendbody!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@extendbody! ff parts::FExpr...</code></pre><p>Extend the body of a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L513-L517">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@field-Tuple{Union{Expr, Symbol}}" href="#Hamiltonian.Utilities.Factory.@field-Tuple{Union{Expr, Symbol}}"><code>Hamiltonian.Utilities.Factory.@field</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@field expr::FExpr</code></pre><p>Construct a <code>Field</code> directly from a field statement.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L280-L284">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@functionfactory-Tuple{Expr}" href="#Hamiltonian.Utilities.Factory.@functionfactory-Tuple{Expr}"><code>Hamiltonian.Utilities.Factory.@functionfactory</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@functionfactory expr::FExpr</code></pre><p>Construct a <code>FunctionFactory</code> directly from a function definition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L416-L420">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@inference-Tuple{Union{Expr, Symbol}}" href="#Hamiltonian.Utilities.Factory.@inference-Tuple{Union{Expr, Symbol}}"><code>Hamiltonian.Utilities.Factory.@inference</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@inference expr::FExpr</code></pre><p>Construct an <code>Inference</code> directly from a type inference.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L151-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@parameter-Tuple{Union{Expr, Symbol}}" href="#Hamiltonian.Utilities.Factory.@parameter-Tuple{Union{Expr, Symbol}}"><code>Hamiltonian.Utilities.Factory.@parameter</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@parameter expr::FExpr</code></pre><p>Construct a <code>Parameter</code> directly from an parameter statement.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L242-L246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@push!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@push! b parts::FExpr...</code></pre><p>Push other parts into the body of a block.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L336-L340">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@rmlines!-Tuple{Expr}" href="#Hamiltonian.Utilities.Factory.@rmlines!-Tuple{Expr}"><code>Hamiltonian.Utilities.Factory.@rmlines!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@rmlines! b::Expr</code></pre><p>Remove line number nodes in the body of a block.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L350-L354">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@rmlines-Tuple{Expr}" href="#Hamiltonian.Utilities.Factory.@rmlines-Tuple{Expr}"><code>Hamiltonian.Utilities.Factory.@rmlines</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@rmlines b::Expr</code></pre><p>Return a copy of a block with the line number nodes removed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L364-L368">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@typefactory-Tuple{Expr}" href="#Hamiltonian.Utilities.Factory.@typefactory-Tuple{Expr}"><code>Hamiltonian.Utilities.Factory.@typefactory</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@typefactory expr::Expr</code></pre><p>Construct a <code>TypeFactory</code> directly from a type definition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L561-L565">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}" href="#Hamiltonian.Utilities.Factory.addargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}"><code>Hamiltonian.Utilities.Factory.addargs!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addargs!(ff::FunctionFactory,args::Argument...)
addargs!(ff::FunctionFactory,args::FExpr...)</code></pre><p>Add a couple of positional arguments to a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L452-L457">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addconstructors!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory}" href="#Hamiltonian.Utilities.Factory.addconstructors!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory}"><code>Hamiltonian.Utilities.Factory.addconstructors!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addconstructors!(tf::TypeFactory,constructors::FunctionFactory...)
addconstructors!(tf::TypeFactory,constructors::Expr...)</code></pre><p>Add a couple of constructors to a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L612-L617">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addfields!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory}" href="#Hamiltonian.Utilities.Factory.addfields!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory}"><code>Hamiltonian.Utilities.Factory.addfields!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addfields!(tf::TypeFactory,fields::Field...)
addfields!(tf::TypeFactory,fields::FExpr...)</code></pre><p>Add a couple of fields to a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L595-L600">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addkwargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}" href="#Hamiltonian.Utilities.Factory.addkwargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}"><code>Hamiltonian.Utilities.Factory.addkwargs!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addkwargs!(ff::FunctionFactory,kwargs::Argument...)
addkwargs!(ff::FunctionFactory,kwargs::FExpr...)</code></pre><p>Add a couple of keyword arguments to a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L469-L474">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addparams!-Tuple{Union{FunctionFactory, TypeFactory}}" href="#Hamiltonian.Utilities.Factory.addparams!-Tuple{Union{FunctionFactory, TypeFactory}}"><code>Hamiltonian.Utilities.Factory.addparams!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addparams!(f::FunctionFactory,params::Inference...)
addparams!(f::TypeFactory,params::Parameter...)
addparams!(f::Union{FunctionFactory,TypeFactory},params::FExpr...)</code></pre><p>Add a couple of parameters to a function factory or a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L629-L635">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addwhereparams!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}" href="#Hamiltonian.Utilities.Factory.addwhereparams!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}"><code>Hamiltonian.Utilities.Factory.addwhereparams!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addwhereparams!(f::FunctionFactory,whereparams::Parameter...)
addwhereparams!(f::FunctionFactory,whereparams::FExpr...)</code></pre><p>Add a couple of method where parameters to a function factory or a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L496-L501">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.escape-Union{Tuple{Any}, Tuple{N}, Tuple{Any,Tuple{Vararg{Symbol,N}}}} where N" href="#Hamiltonian.Utilities.Factory.escape-Union{Tuple{Any}, Tuple{N}, Tuple{Any,Tuple{Vararg{Symbol,N}}}} where N"><code>Hamiltonian.Utilities.Factory.escape</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">escape(expr,::NTuple{N,Symbol}=()) where N
escape(expr::Symbol,escaped::NTuple{N,Symbol}=()) where N
escape(expr::Expr,escaped::NTuple{N,Symbol}=()) where N</code></pre><p>Escape the variables sepecified by <code>escaped</code> in the input expression.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L50-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.extendbody!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}" href="#Hamiltonian.Utilities.Factory.extendbody!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory}"><code>Hamiltonian.Utilities.Factory.extendbody!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">extendbody!(ff::FunctionFactory,parts::FExpr...)
extendbody!(ff::FunctionFactory,parts::Block...)</code></pre><p>Extend the body of a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L486-L491">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.rmlines!-Tuple{Hamiltonian.Utilities.Factory.Block}" href="#Hamiltonian.Utilities.Factory.rmlines!-Tuple{Hamiltonian.Utilities.Factory.Block}"><code>Hamiltonian.Utilities.Factory.rmlines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rmlines!(b::Block)</code></pre><p>Remove line number nodes in the body of a block.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L343-L347">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.rmlines-Tuple{Hamiltonian.Utilities.Factory.Block}" href="#MacroTools.rmlines-Tuple{Hamiltonian.Utilities.Factory.Block}"><code>MacroTools.rmlines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rmlines(b::Block)</code></pre><p>Return a copy of a block with the line number nodes removed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L357-L361">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.AbstractFactory" href="#Hamiltonian.Utilities.Factory.AbstractFactory"><code>Hamiltonian.Utilities.Factory.AbstractFactory</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractFactory</code></pre><p>Abstract type for all concrete factories.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L61-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Union{Tuple{F}, Tuple{F,F}} where F&lt;:Hamiltonian.Utilities.Factory.AbstractFactory" href="#Base.:==-Union{Tuple{F}, Tuple{F,F}} where F&lt;:Hamiltonian.Utilities.Factory.AbstractFactory"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">==(f1::F,f2::F) where F&lt;:AbstractFactory</code></pre><p>Overloaded <code>==</code> operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L68-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.names-Tuple{Any}" href="#Base.names-Tuple{Any}"><code>Base.names</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">names(expr::Union{Symbol,Expr})</code></pre><p>Get all the variable names in an <code>Expr</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L35-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Tuple{Hamiltonian.Utilities.Factory.Block}" href="#Base.push!-Tuple{Hamiltonian.Utilities.Factory.Block}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">push!(b::Block,parts::FExpr...)
push!(b::Block,parts::Block...)</code></pre><p>Push other parts into the body of a block.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L322-L327">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.replace-Tuple{Hamiltonian.Utilities.Factory.AbstractFactory}" href="#Base.replace-Tuple{Hamiltonian.Utilities.Factory.AbstractFactory}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">replace(f::AbstractFactory;kwargs...)</code></pre><p>Return a copy of a concrete <code>AbstractFactory</code> with some of the field values replaced by the keyword arguments.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L106-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Tuple{IO,Hamiltonian.Utilities.Factory.AbstractFactory}" href="#Base.show-Tuple{IO,Hamiltonian.Utilities.Factory.AbstractFactory}"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">show(io::IO,f::AbstractFactory)</code></pre><p>Show a concrete <code>AbstractFactory</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/28a22209f4846db25a57c3db87d53e49995913b0/src/Utilities/Factory.jl#L75-L79">source</a></section><footer><hr/><a class="previous" href="Introduction.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="Tree.html"><span class="direction">Next</span><span class="title">Tree</span></a></footer></article></body></html>
