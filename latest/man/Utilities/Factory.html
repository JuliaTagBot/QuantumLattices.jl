<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Factory · Hamiltonian.jl</title><link rel="canonical" href="https://quantum-many-body.github.io/Hamiltonian.jl/latest/man/Utilities/Factory.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Hamiltonian.jl logo"/></a><h1>Hamiltonian.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">Home</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../../tutorial/Unitcell Description.html">Unitcell Description</a></li><li><a class="toctext" href="../../tutorial/Engine App Interface.html">Engine App Interface</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><span class="toctext">Utilities</span><ul><li><a class="toctext" href="Introduction.html">Introduction</a></li><li class="current"><a class="toctext" href="Factory.html">Factory</a><ul class="internal"><li><a class="toctext" href="#Block-1">Block</a></li><li><a class="toctext" href="#Argument-1">Argument</a></li><li><a class="toctext" href="#FunctionFactory-1">FunctionFactory</a></li><li><a class="toctext" href="#Field-1">Field</a></li><li><a class="toctext" href="#Type-Factory-1">Type Factory</a></li><li><a class="toctext" href="#Manual-1">Manual</a></li></ul></li><li><a class="toctext" href="Tree.html">Tree</a></li><li><a class="toctext" href="NamedVector.html">Named vector</a></li><li><a class="toctext" href="GoodQuantumNumber.html">Good quantum numbers</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li>Utilities</li><li><a href="Factory.html">Factory</a></li></ul><a class="edit-page" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/master/docs/src/man/Utilities/Factory.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Factory</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Factory-1" href="#Factory-1">Factory</a></h1><p>The aim of <code>Factory</code> is to provide tools to hack into Julia codes without knowing the details of their abstract syntax trees, so that users can somewhat manipulate the existing codes, modify them and generate new ones. In particular, <code>Factory</code> in this module means the representation of certain blocks of Julia codes by a usual Julia struct. This representation is much easier to comprehend than the canonical <code>Expr</code> representation. In general, we propose two basic requirements that any factory must satisfy:</p><ul><li>Besides the default constructor, a concrete factory can be constructed from any legal <code>Expr</code> expression that represents the block of codes it aims to represent;</li><li>The canonical <code>Expr</code> expression of the block of codes that a concrete factory represents can be obtained by &quot;calling&quot; the factory itself.</li></ul><p>These two requirements also defines the basic interfaces to interact with factories.</p><p>Out of practical purposes, we only implemente 5 kinds of factories, i.e. <em><a href="Factory.html#Hamiltonian.Utilities.Factory.Block"><code>Block</code></a></em>, <em><a href="Factory.html#Hamiltonian.Utilities.Factory.Argument"><code>Argument</code></a></em>, <em><a href="Factory.html#Hamiltonian.Utilities.Factory.FunctionFactory"><code>FunctionFactory</code></a></em>, <em><a href="Factory.html#Hamiltonian.Utilities.Factory.Field"><code>Field</code></a></em> and <em><a href="Factory.html#Hamiltonian.Utilities.Factory.TypeFactory"><code>TypeFactory</code></a></em>, which represent <em>a <code>begin ... end</code> block</em>, <em>an argument of a function</em>, <em>a function itself</em>, <em>a field of a struct</em> and <em>a struct itself</em>, respectively. Some of the basic methods making the above requirements fulfilled with these types are based on the powerful functions defined in <a href="https://github.com/MikeInnes/MacroTools.jl"><code>MacroTools</code></a>.</p><h2><a class="nav-anchor" id="Block-1" href="#Block-1">Block</a></h2><p>A <code>Block</code> has only one attribute:</p><ul><li><code>body::Vector{Any}</code>: the body of the <code>begin ... end</code> block</li></ul><p>Any expression can be passed to the constructor of <code>Block</code>, such as:</p><ul><li><pre><code class="language-julia">:(x=1)</code></pre></li><li><pre><code class="language-julia">:(x=1;y=2)</code></pre></li><li><pre><code class="language-julia">:(begin x=1 end)</code></pre></li><li><pre><code class="language-julia">quote
    x=1
    y=2
end</code></pre></li></ul><p>Or you can construct a <code>Block</code> instance directly from any code by the macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@block-Tuple{Vararg{Union{Expr, Symbol},N} where N}"><code>@block</code></a>:</p><pre><code class="language-julia">@block x=1 y=2</code></pre><p>whose result is equivalent to</p><pre><code class="language-julia">Block(Expr(:block,:(x=1),:(y=2)))</code></pre><p>The body of a <code>block</code> can also be extended by the <a href="Factory.html#Base.push!-Tuple{Hamiltonian.Utilities.Factory.Block,Vararg{Union{Expr, Symbol},N} where N}"><code>push!</code></a> function or the <a href="Factory.html#Hamiltonian.Utilities.Factory.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@push!</code></a> macro.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The body of a <code>Block</code> is somewhat &quot;flattened&quot;, i.e. it contains no <code>begin ... end</code> blocks. During the initialization, any such input block will be unblocked and added to the body part by part. So is the <a href="Factory.html#Base.push!-Tuple{Hamiltonian.Utilities.Factory.Block,Vararg{Union{Expr, Symbol},N} where N}"><code>push!</code></a> and <a href="Factory.html#Hamiltonian.Utilities.Factory.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@push!</code></a> processes.</p></div></div><h2><a class="nav-anchor" id="Argument-1" href="#Argument-1">Argument</a></h2><p>An <code>Argument</code> has 4 attributes:</p><ul><li><code>name::Symbol</code>: the name of the argument</li><li><code>type::Union{Symbol,Expr}</code>: the type of the argument</li><li><code>slurp::Bool</code>: whether the argument should be expanded by <code>...</code></li><li><code>default::Any</code>: the default value of the argument, <code>nothing</code> for those with no default values</li></ul><p>Valid expressions that can be passed to the constructor include:</p><ul><li><pre><code class="language-julia">:(arg)</code></pre></li><li><pre><code class="language-julia">:(arg::ArgType)</code></pre></li><li><pre><code class="language-julia">:(arg::ArgType...)</code></pre></li><li><pre><code class="language-julia">:(arg::ArgType=default)</code></pre></li></ul><p>Or you can use the macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@argument-Tuple{Union{Expr, Symbol}}"><code>@argument</code></a> for construction directly from an argument declaration:</p><pre><code class="language-julia">@argument arg::ArgType=default</code></pre><p>The construction from such expressions is based on the the <code>MacroTools.splitarg</code> function. On the other hand, calling an instance of <code>Argument</code> will get the corresponding <code>Expr</code> expression, e.g.,</p><pre><code class="language-julia">Argument(:arg,:ArgType,false,default)()</code></pre><p>will return</p><pre><code class="language-julia">:(arg::ArgType=default)</code></pre><p>This feature is based on the <code>MacroTools.combinearg</code> function.</p><h2><a class="nav-anchor" id="FunctionFactory-1" href="#FunctionFactory-1">FunctionFactory</a></h2><p>A <code>FunctionFactory</code> has 6 attributes:</p><ul><li><code>name::Symbol</code>: the name of the function</li><li><code>args::Vector{Union{Symbol,Expr}}</code>: the positional arguments of the function</li><li><code>kwargs::Vector{Union{Symbol,Expr}}</code>: the keyword arguments of the function</li><li><code>rtype::Union{Symbol,Expr}</code>: the return type of the function</li><li><code>params::Vector{Union{Symbol,Expr}}</code>: the method parameters specified by the <code>where</code> keyword</li><li><code>body::Union{Symbol,Expr}</code>: the body of the function</li></ul><p>All expressions that represent functions are allowed to be passed to the constructor, such as:</p><ul><li><pre><code class="language-julia">:(f()=nothing)</code></pre></li><li><pre><code class="language-julia">:(f(x)=x)</code></pre></li><li><pre><code class="language-julia">:(f(x::Int,y::Int;choice::Function=sum)=choice(x,y))</code></pre></li><li><pre><code class="language-julia">:(f(x::T,y::T;choice::Function=sum) where T&lt;:Number=choice(x,y))</code></pre></li><li><pre><code class="language-julia">:((f(x::T,y::T;choice::Function=sum)::T) where T&lt;:Number=choice(x,y))</code></pre></li><li><pre><code class="language-julia">:(function (f(x::T,y::T;choice::Function=sum)::T) where T&lt;:Numbe
      choice(x,y)
  end
)</code></pre></li><li><pre><code class="language-julia">quote
    function (f(x::T,y::T;choice::Function=sum)::T) where T&lt;:Numbe
        choice(x,y)
    end
end</code></pre></li></ul><p>Similarly, an instance can also be constructed from the macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@functionfactory-Tuple{Expr}"><code>@functionfactory</code></a>:</p><pre><code class="language-julia">@functionfactory (f(x::T,y::T;choice::Function=sum)::T) where T&lt;:Number=choice(x,y)</code></pre><p>The construction from and the convertion to such expressions are based on the <code>MacroTools.splitdef</code> and <code>MacroTools.combinedef</code> functions, respectively.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Because the form <code>f{T}(x::T,y::T;choice::Function=sum)</code> has no longer been supported since Julia 0.7, the entry <code>:params</code> in the returned dict by <code>MacroTools.splitarg</code> is always missing. Therefore, we abandon its corresponding field in <code>FunctionFactory</code> but use the attribute <code>:params</code> to denote the <code>:whereparams</code> entry.</p></div></div><p>Other features include:</p><ul><li>Positional arguments can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory,Vararg{Union{Expr, Symbol},N} where N}"><code>addargs!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addargs!</code></a></li><li>Keyword arguments can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addkwargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory,Vararg{Union{Expr, Symbol},N} where N}"><code>addkwargs!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addkwargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addkwargs!</code></a></li><li>Body can be extended by <a href="Factory.html#Hamiltonian.Utilities.Factory.extendbody!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory,Vararg{Union{Expr, Symbol},N} where N}"><code>extendbody!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@extendbody!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@extendbody!</code></a></li></ul><h2><a class="nav-anchor" id="Field-1" href="#Field-1">Field</a></h2><p>A <a href="Factory.html#Hamiltonian.Utilities.Factory.Field"><code>Field</code></a> has 2 attributes:</p><ul><li><code>name::Symbol</code>: the name of the field</li><li><code>type::Union{Symbol,Expr}</code>: the type of the field</li></ul><p>Legal expressions that can be passed to the constructor includes the following forms:</p><ul><li><pre><code class="language-julia">:(field)</code></pre></li><li><pre><code class="language-julia">:(field::FieldType)</code></pre></li><li><pre><code class="language-julia">:(field::ParametricType{Parameter})</code></pre></li></ul><p>The macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@field-Tuple{Union{Expr, Symbol}}"><code>@field</code></a> is also provided to help the construction directly from a field declaration:</p><pre><code class="language-julia">@field field::FieldType</code></pre><p>The construction from these expressions is based on the <code>MacroTools.splitarg</code> function and the convertion to these expressions is based on the <code>MacroTools.combinefield</code> function.</p><h2><a class="nav-anchor" id="Type-Factory-1" href="#Type-Factory-1">Type Factory</a></h2><p>A <a href="Factory.html#Hamiltonian.Utilities.Factory.TypeFactory"><code>TypeFactory</code></a> has 6 attributes:</p><ul><li><code>name::Symbol</code>: the name of the struct</li><li><code>mutable::Bool</code>: whether or not the struct is mutable</li><li><code>params::Vector{Union{Symbol,Expr}}</code>: the type parameters of the struct</li><li><code>supertype::Union{Symbol,Expr}</code>: the supertype of the struct</li><li><code>fields::Vector{Tuple{Symbol,Union{Symbol,Expr}}}</code>: the fields of the struct</li><li><code>constructors::Vector{Expr}</code>: the inner constructors of the struct</li></ul><p>Any expression representing valid struct definitions can be passed to the constructor, whose common forms include the followings:</p><ul><li><pre><code class="language-julia">:(struct StructName end)</code></pre></li><li><pre><code class="language-julia">:(struct StructName{T} end)</code></pre></li><li><pre><code class="language-julia">:(struct Child{T} &lt;: Parent{T} where T end)</code></pre></li><li><pre><code class="language-julia">:(struct Child{T} &lt;: Parent{T} where T&lt;:TypeParameter
      field1::FiledType1
      filed2::FieldType2
  end
)</code></pre></li><li><pre><code class="language-julia">quote
    struct Child{T} &lt;: Parent{T} where T&lt;:TypeParameter
        field1::FiledType1
        filed2::FieldType2
    end
end</code></pre></li></ul><p>Also, the macro <a href="Factory.html#Hamiltonian.Utilities.Factory.@typefactory-Tuple{Expr}"><code>@typefactory</code></a> simplifies the construction directly from a type definition:</p><pre><code class="language-julia">@typefactory struct Child{T} &lt;: Parent{T} where T&lt;:TypeParameter
                field1::FiledType1
                filed2::FieldType2
            end</code></pre><p>The construction from these expressions is based on the <code>MacroTools.splitstructdef</code> function. Meanwhile, the convertion to the corresponding expression from a <code>TypeFactory</code> is based on the <code>MacroTools.combinestructdef</code> function.</p><p>Other features include:</p><ul><li>Fields can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addfields!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory,Vararg{Union{Expr, Symbol},N} where N}"><code>addfields!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addfields!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addfields!</code></a></li><li>Inner constructors can be added by <a href="Factory.html#Hamiltonian.Utilities.Factory.addconstructors!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory,Vararg{Expr,N} where N}"><code>addconstructors!</code></a> or <a href="Factory.html#Hamiltonian.Utilities.Factory.@addconstructors!-Tuple{Any,Vararg{Expr,N} where N}"><code>@addconstructors!</code></a></li></ul><h2><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Argument" href="#Hamiltonian.Utilities.Factory.Argument"><code>Hamiltonian.Utilities.Factory.Argument</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Argument(name::Symbol,type::FExpr,slurp::Bool,default::Any)
Argument(name::Symbol;type::FExpr=:Any,slurp::Bool=false,default::Any=nothing)
Argument(expr::Expr)</code></pre><p>The struct to describe a argument of a <code>function</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L90-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Argument-Tuple{}" href="#Hamiltonian.Utilities.Factory.Argument-Tuple{}"><code>Hamiltonian.Utilities.Factory.Argument</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(a::Argument)()</code></pre><p>Convert a <code>Argument</code> to the <code>Expr</code> representation of the argument it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L117-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Block" href="#Hamiltonian.Utilities.Factory.Block"><code>Hamiltonian.Utilities.Factory.Block</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Block(parts::FExpr...)</code></pre><p>The struct to describe a <code>begin ... end</code> block.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L46-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Block-Tuple{}" href="#Hamiltonian.Utilities.Factory.Block-Tuple{}"><code>Hamiltonian.Utilities.Factory.Block</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(b::Block)()</code></pre><p>Convert a <code>Block</code> to the <code>Expr</code> representation of the <code>begin ... end</code> block it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L63-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Field" href="#Hamiltonian.Utilities.Factory.Field"><code>Hamiltonian.Utilities.Factory.Field</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Field(name::Symbol,type::FExpr)
Field(name::Symbol;type::FExpr=:Any)
Field(expr::Expr)</code></pre><p>The struct to describe a field of a <code>struct</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L217-L223">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.Field-Tuple{}" href="#Hamiltonian.Utilities.Factory.Field-Tuple{}"><code>Hamiltonian.Utilities.Factory.Field</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(f::Field)()</code></pre><p>Convert a <code>Field</code> to the <code>Expr</code> representation of the field it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L242-L246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.FunctionFactory" href="#Hamiltonian.Utilities.Factory.FunctionFactory"><code>Hamiltonian.Utilities.Factory.FunctionFactory</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FunctionFactory(name::Symbol,args::Vector,kwargs::Vector,rtype::FExpr,params::Vector,body::FExpr)
FunctionFactory(name::Symbol;args::Vector=Any[],kwargs::Vector=Any[],rtype::FExpr=:Any,params::Vector=Any[],body::FExpr)
FunctionFactory(expr::Expr)</code></pre><p>The struct to describe a <code>function</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L124-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.FunctionFactory-Tuple{}" href="#Hamiltonian.Utilities.Factory.FunctionFactory-Tuple{}"><code>Hamiltonian.Utilities.Factory.FunctionFactory</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(ff::FunctionFactory)()</code></pre><p>Convert a <code>FunctionFactory</code> to the <code>Expr</code> representation of the <code>function</code> it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L158-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.TypeFactory" href="#Hamiltonian.Utilities.Factory.TypeFactory"><code>Hamiltonian.Utilities.Factory.TypeFactory</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TypeFactory(name::Symbol,mutable::Bool,params::Vector,supertype::FExpr,fields::Vector,constructors::Vector)
TypeFactory(name::Symbol;mutable::Bool=false,params::Vector=Any[],supertype::FExpr=:Any,fields::Vector=Any[],constructors::Vector=Any[])
TypeFactory(expr::Expr)</code></pre><p>The struct to describe a <code>struct</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L249-L255">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.TypeFactory-Tuple{}" href="#Hamiltonian.Utilities.Factory.TypeFactory-Tuple{}"><code>Hamiltonian.Utilities.Factory.TypeFactory</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(tf::TypeFactory)()</code></pre><p>Convert a <code>TypeFactory</code> to the <code>Expr</code> representation of the <code>struct</code> it describes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L283-L287">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@addargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@addargs!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addargs! ff args::FExpr...</code></pre><p>Add a couple of positional arguments to a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L174-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addconstructors!-Tuple{Any,Vararg{Expr,N} where N}" href="#Hamiltonian.Utilities.Factory.@addconstructors!-Tuple{Any,Vararg{Expr,N} where N}"><code>Hamiltonian.Utilities.Factory.@addconstructors!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addconstructors! rf constructors::Expr...</code></pre><p>Add a couple of constructors to a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L315-L319">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addfields!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@addfields!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@addfields!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addfields! rf fields::FExpr...</code></pre><p>Add a couple of fields to a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L299-L303">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@addkwargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@addkwargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@addkwargs!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@addkwargs! ff kwargs::FExpr...</code></pre><p>Add a couple of keyword arguments to a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L190-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@argument-Tuple{Union{Expr, Symbol}}" href="#Hamiltonian.Utilities.Factory.@argument-Tuple{Union{Expr, Symbol}}"><code>Hamiltonian.Utilities.Factory.@argument</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@argument expr::FExpr</code></pre><p>Construct an <code>Argument</code> directly from an argument statement.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L107-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@block-Tuple{Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@block-Tuple{Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@block</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@block parts::FExpr...</code></pre><p>Construct a <code>Block</code> directly from a <code>begin ... end</code> block definition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L56-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@extendbody!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@extendbody!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@extendbody!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@extendbody! ff parts::FExpr...</code></pre><p>Extend the body of a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L210-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@field-Tuple{Union{Expr, Symbol}}" href="#Hamiltonian.Utilities.Factory.@field-Tuple{Union{Expr, Symbol}}"><code>Hamiltonian.Utilities.Factory.@field</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@field expr::FExpr</code></pre><p>Construct a <code>Field</code> directly from a field statement.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L232-L236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@functionfactory-Tuple{Expr}" href="#Hamiltonian.Utilities.Factory.@functionfactory-Tuple{Expr}"><code>Hamiltonian.Utilities.Factory.@functionfactory</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@functionfactory expr::Expr</code></pre><p>Construct a <code>FunctionFactory</code> directly from a function definition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L148-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.@push!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@push! b parts::FExpr...</code></pre><p>Push other parts into the body of a block.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L83-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.@typefactory-Tuple{Expr}" href="#Hamiltonian.Utilities.Factory.@typefactory-Tuple{Expr}"><code>Hamiltonian.Utilities.Factory.@typefactory</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@typefactory expr::Expr</code></pre><p>Construct a <code>TypeFactory</code> directly from a type definition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L273-L277">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.addargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.addargs!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addargs!(ff::FunctionFactory,args::FExpr...)
addargs!(ff::FunctionFactory,args::Argument...)</code></pre><p>Add a couple of positional arguments to a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L165-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addconstructors!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory,Vararg{Expr,N} where N}" href="#Hamiltonian.Utilities.Factory.addconstructors!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory,Vararg{Expr,N} where N}"><code>Hamiltonian.Utilities.Factory.addconstructors!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addconstructors!(rf::TypeFactory,constructors::Expr...)
addconstructors!(rf::TypeFactory,constructors::FunctionFactory...)</code></pre><p>Add a couple of constructors to a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L306-L311">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addfields!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.addfields!-Tuple{Hamiltonian.Utilities.Factory.TypeFactory,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.addfields!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addfields!(rf::TypeFactory,fields::FExpr...)
addfields!(rf::TypeFactory,fields::Field...)</code></pre><p>Add a couple of fields to a type factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L290-L295">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.addkwargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.addkwargs!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.addkwargs!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">addkwargs!(ff::FunctionFactory,kwargs::FExpr...)
addkwargs!(ff::FunctionFactory,kwargs::Argument...)</code></pre><p>Add a couple of keyword arguments to a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L181-L186">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.extendbody!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory,Vararg{Union{Expr, Symbol},N} where N}" href="#Hamiltonian.Utilities.Factory.extendbody!-Tuple{Hamiltonian.Utilities.Factory.FunctionFactory,Vararg{Union{Expr, Symbol},N} where N}"><code>Hamiltonian.Utilities.Factory.extendbody!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">extendbody!(ff::FunctionFactory,parts::FExpr...)
extendbody!(ff::FunctionFactory,parts::Block...)</code></pre><p>Extend the body of a function factory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L197-L202">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.FExpr" href="#Hamiltonian.Utilities.Factory.FExpr"><code>Hamiltonian.Utilities.Factory.FExpr</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Factory expression types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Hamiltonian.Utilities.Factory.AbstractFactory" href="#Hamiltonian.Utilities.Factory.AbstractFactory"><code>Hamiltonian.Utilities.Factory.AbstractFactory</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractFactory</code></pre><p>Abstract type for all concrete factories.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L18-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Union{Tuple{F}, Tuple{F,F}} where F&lt;:Hamiltonian.Utilities.Factory.AbstractFactory" href="#Base.:==-Union{Tuple{F}, Tuple{F,F}} where F&lt;:Hamiltonian.Utilities.Factory.AbstractFactory"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">==(f1::F,f2::F) where F&lt;:AbstractFactory</code></pre><p>Overloaded <code>==</code> operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L25-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Tuple{Hamiltonian.Utilities.Factory.Block,Vararg{Union{Expr, Symbol},N} where N}" href="#Base.push!-Tuple{Hamiltonian.Utilities.Factory.Block,Vararg{Union{Expr, Symbol},N} where N}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">push!(b::Block,parts::FExpr...)
push!(b::Block,parts::Block...)</code></pre><p>Push other parts into the body of a block.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L70-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.replace-Tuple{Hamiltonian.Utilities.Factory.AbstractFactory}" href="#Base.replace-Tuple{Hamiltonian.Utilities.Factory.AbstractFactory}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">replace(f::AbstractFactory;kwargs...)</code></pre><p>Return a copy of a concrete <code>AbstractFactory</code> with some of the field values replaced by the keyword arguments.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L39-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Tuple{IO,Hamiltonian.Utilities.Factory.AbstractFactory}" href="#Base.show-Tuple{IO,Hamiltonian.Utilities.Factory.AbstractFactory}"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">show(io::IO,f::AbstractFactory)</code></pre><p>Show a concrete <code>AbstractFactory</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Quantum-Many-Body/Hamiltonian.jl/blob/4f48a29b1ff4a4b88c1e2a21ff1b26864d56af2b/src/Utilities/Factory.jl#L32-L36">source</a></section><footer><hr/><a class="previous" href="Introduction.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="Tree.html"><span class="direction">Next</span><span class="title">Tree</span></a></footer></article></body></html>
