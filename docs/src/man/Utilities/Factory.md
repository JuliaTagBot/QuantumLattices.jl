```@meta
CurrentModule=Hamiltonian.Utilities.Factory
```

```@setup factory
push!(LOAD_PATH,"../../../../src/")
using Hamiltonian.Utilities.Factory
```

# Factory

The aim of `Factory` is to provide tools to hack into Julia codes without knowing the details of their abstract syntax trees, so that users can somewhat manipulate the existing codes, modify them and generate new ones. In particular, `Factory` in this module means the representation of certain blocks of Julia codes by a usual Julia struct. This representation is much easier to comprehend than the canonical `Expr` representation. In general, we propose two basic requirements that any factory must satisfy:
* Besides the default constructor, a concrete factory can be constructed from any legal `Expr` expression that represents the block of codes it aims to represent;
* The canonical `Expr` expression of the block of codes that a concrete factory represents can be obtained by "calling" the factory itself.
These two requirements also defines the basic interfaces to interact with factories.

Out of practical purposes, we only implemente 6 kinds of factories, i.e. *[`Argument`](@ref)*, *[`Parameter`](@ref)*, *[`Field`](@ref)*, *[`Block`](@ref)*, *[`FunctionFactory`](@ref)* and *[`TypeFactory`](@ref)*, which represent *a function argument*, *a method or type parameter*, *a struct field*, *a `begin ... end` block*, *a function itself* and *a struct itself*, respectively. Some of the basic methods making the above requirements fulfilled with these types are based on the powerful functions defined in [`MacroTools`](https://github.com/MikeInnes/MacroTools.jl).

## Argument

An [`Argument`](@ref) has 4 attributes:
* `name::Symbol`: the name of the argument
* `type::Union{Symbol,Expr}`: the type of the argument
* `slurp::Bool`: whether the argument should be expanded by `...`
* `default::Any`: the default value of the argument, `nothing` for those with no default values
All valid expressions representing the arguments of functions can be passed to the constructor:
```@repl factory
Argument(:arg)
Argument(:(arg::ArgType))
Argument(:(arg::ArgType...))
Argument(:(arg::ArgType=default))
```
Or you can use the macro [`@argument`](@ref) for construction directly from an argument declaration:
```@repl factory
@argument arg::ArgType=default
```
The construction from such expressions is based on the the `MacroTools.splitarg` function. On the other hand, calling an instance of `Argument` will get the corresponding `Expr` expression, e.g.,
```julia-repl
julia> Argument(:arg,:ArgType,false,:default)()
:(arg::ArgType=default)
```
This feature is based on the `MacroTools.combinearg` function.

## Parameter

A [`Parameter`](@ref) has 2 attributes:
* `name::Symbol`: the name of the parameter
* `type::Union{Symbol,Expr}`: the type of the parameter
All expressions that represent a type parameter or a method parameter are allowed to be passed to the constructor:
```@repl factory
Parameter(:Int)
Parameter(:T)
Parameter(:(<:Number))
Parameter(:(T<:Number))
```
The macro [`@parameter`](@ref) completes the construction directly from a parameter declaration:
```@repl factory
@parameter T<:Number
```

## Field

A [`Field`](@ref) has 2 attributes:
* `name::Symbol`: the name of the field
* `type::Union{Symbol,Expr}`: the type of the field
Legal expressions can be used to construct a `Field` instance by its constructor:
```@repl factory
Field(:field)
Field(:(field::FieldType))
Field(:(field::ParametricType{Parameter}))
```
The macro [`@field`](@ref) is also provided to help the construction directly from a field declaration:
```@repl factory
@field field::FieldType
```
The construction from these expressions is based on the `MacroTools.splitarg` function and the convertion to these expressions is based on the `MacroTools.combinefield` function.

## Block

A [`Block`](@ref) has only one attribute:
* `body::Vector{Any}`: the body of the `begin ... end` block
Any expression can be passed to the constructor of `Block`:
```@repl factory
Block(:(x=1))
Block(:(x=1;y=2))
Block(:(begin x=1 end))
Block(quote
        x=1
        y=2
    end)
```
Or you can construct a `Block` instance directly from any code by the macro [`@block`](@ref):
```@repl factory
@block x=1 y=2
```
The body of a `block` can also be extended by the [`push!`](@ref) function or the [`@push!`](@ref) macro.
!!! note
    1. The body of a `Block` is somewhat "flattened", i.e. it contains no `begin ... end` blocks. During the initialization, any such input block will be unblocked and added to the body part by part. So is the [`push!`](@ref) and [`@push!`](@ref) processes.
    2. All `LineNumberNode`s generated by the input codes will also be included in the block's body. However, you can use [`rmlines!`](@ref) or [`@rmlines!`](@ref) to remove them from the body of an existing `Block`, or use [`rmlines`](@ref) or [`@rmlines`](@ref) to get a copy with them removed in the body.

## FunctionFactory

A [`FunctionFactory`](@ref) has 6 attributes:
* `name::Symbol`: the name of the function
* `args::Vector{Argument}`: the positional arguments of the function
* `kwargs::Vector{Argument}`: the keyword arguments of the function
* `rtype::Any`: the return type of the function
* `params::Vector{Parameter}`: the method parameters specified by the `where` keyword
* `body::Expr`: the body of the function
All expressions that represent functions are allowed to be passed to the constructor:
```@repl factory
FunctionFactory(:(f()=nothing))
FunctionFactory(:(f(x)=x))
FunctionFactory(:(f(x::Int,y::Int;choice::Function=sum)=choice(x,y)))
FunctionFactory(:(f(x::T,y::T;choice::Function=sum) where T<:Number=choice(x,y)))
FunctionFactory(:((f(x::T,y::T;choice::Function=sum)::T) where T<:Number=choice(x,y)))
FunctionFactory(:(
    function (f(x::T,y::T;choice::Function=sum)::T) where T<:Number
        choice(x,y)
    end
))
FunctionFactory(quote
    function (f(x::T,y::T;choice::Function=sum)::T) where T<:Number
        choice(x,y)
    end
end)
```
Similarly, an instance can also be constructed from the macro [`@functionfactory`](@ref):
```@repl factory
@functionfactory (f(x::T,y::T;choice::Function=sum)::T) where T<:Number=choice(x,y)
```
The construction from and the convertion to such expressions are based on the `MacroTools.splitdef` and `MacroTools.combinedef` functions, respectively.
!!! note
    Because the form `f{T}(x::T,y::T;choice::Function=sum)` has no longer been supported since Julia 0.7, the entry `:params` in the returned dict by `MacroTools.splitarg` is always missing. Therefore, we abandon its corresponding field in `FunctionFactory` but use the attribute `:params` to denote the `:whereparams` entry.

Other features include:
* Positional arguments can be added by [`addargs!`](@ref) or [`@addargs!`](@ref)
* Keyword arguments can be added by [`addkwargs!`](@ref) or [`@addkwargs!`](@ref)
* Method parameters can be added by [`addparams!`](@ref) or [`@addparams!`](@ref)
* Body can be extended by [`extendbody!`](@ref) or [`@extendbody!`](@ref)

## TypeFactory

A [`TypeFactory`](@ref) has 6 attributes:
* `name::Symbol`: the name of the struct
* `mutable::Bool`: whether or not the struct is mutable
* `params::Vector{Parameter}`: the type parameters of the struct
* `supertype::Any`: the supertype of the struct
* `fields::Vector{Field}`: the fields of the struct
* `constructors::Vector{FunctionFactory}`: the inner constructors of the struct
Any expression representing valid struct definitions can be passed to the constructor:
```@repl factory
TypeFactory(:(struct StructName end))
TypeFactory(:(struct StructName{T} end))
TypeFactory(:(struct Child{T} <: Parent{T} where T end))
TypeFactory(:(
    struct Child{T} <: Parent{T} where T<:TypeParameter
        field1::T
        field2::T
    end
))
TypeFactory(quote
    struct Child{T} <: Parent{T} where T<:TypeParameter
        field1::T
        field2::T
    end
end)
```
Also, the macro [`@typefactory`](@ref) supports the construction directly from a type definition:
```@repl factory
@typefactory struct Child{T} <: Parent{T} where T<:TypeParameter
                field1::T
                field2::T
                Child(field1::T,field2::T=zero(T)) where T=new{T}(field1,field2)
            end
```
The construction from these expressions is based on the `MacroTools.splitstructdef` function. Meanwhile, the convertion to the corresponding expression from a `TypeFactory` is based on the `MacroTools.combinestructdef` function.

Other features include:
* Fields can be added by [`addfields!`](@ref) or [`@addfields!`](@ref)
* Type parameters can be added by [`addparams!`](@ref) or [`@addparams!`](@ref)
* Inner constructors can be added by [`addconstructors!`](@ref) or [`@addconstructors!`](@ref)

## Manual

```@autodocs
Modules=[Factory]
Order=  [:module,:constant,:type,:macro,:function]
```
